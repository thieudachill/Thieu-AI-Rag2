<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matthew's Digital Space | AI-Powered Portfolio</title>
    <meta name="description" content="Welcome to Matthew's digital space. Explore AI innovations and chat with my intelligent assistant about my work and expertise.">
    <meta name="keywords" content="AI, Machine Learning, Business Innovation, RAG, Chatbot, Portfolio, Matthew">
    <meta name="author" content="Matthew">
    <meta name="robots" content="index, follow">
    
    <!-- Open Graph / Social Media -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://thieu-ai-rag2.vercel.app/">
    <meta property="og:title" content="Matthew's AI-Powered Digital Space">
    <meta property="og:description" content="Experience cutting-edge AI technology with my intelligent assistant. Ask questions about my work and projects in English or Vietnamese.">
    <meta property="og:image" content="https://thieu-ai-rag2.vercel.app/og-image.jpg">
    
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://thieu-ai-rag2.vercel.app/">
    <meta name="twitter:title" content="Matthew's AI-Powered Digital Space">
    <meta name="twitter:description" content="Chat with my AI assistant powered by RAG technology">
    
    <!-- Performance optimizations -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
    <link rel="dns-prefetch" href="https://505a-2405-4803-d738-6750-dcce-d1a4-a784-f659.ngrok-free.app">
    
    <!-- Security headers -->
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta http-equiv="X-Frame-Options" content="DENY">
    <meta http-equiv="X-XSS-Protection" content="1; mode=block">
    <meta name="referrer" content="strict-origin-when-cross-origin">
    
    <!-- Theme and PWA -->
    <meta name="theme-color" content="#6366f1">
    <meta name="color-scheme" content="light">
    <link rel="manifest" href="data:application/json,{&quot;name&quot;:&quot;Matthew AI&quot;,&quot;short_name&quot;:&quot;Matthew.AI&quot;,&quot;display&quot;:&quot;standalone&quot;,&quot;background_color&quot;:&quot;#6366f1&quot;,&quot;theme_color&quot;:&quot;#6366f1&quot;}">
    
    <!-- Fonts with optimized loading -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Enhanced favicon -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>🤖</text></svg>">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 180 180'><rect width='180' height='180' rx='40' fill='%236366f1'/><text x='90' y='110' font-size='90' text-anchor='middle'>🤖</text></svg>">
    
    <!-- Structured Data for SEO -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "Person",
        "name": "Matthew",
        "jobTitle": "AI Engineer & Business Innovation Specialist",
        "description": "Tech enthusiast exploring AI and business innovation with RAG technology",
        "url": "https://thieu-ai-rag2.vercel.app/",
        "knowsAbout": ["Artificial Intelligence", "Machine Learning", "Business Innovation", "RAG Technology", "n8n Automation"],
        "alumniOf": {
            "@type": "EducationalOrganization",
            "name": "FPT University"
        },
        "hasOccupation": {
            "@type": "Occupation",
            "name": "AI Engineer",
            "occupationLocation": {
                "@type": "Place",
                "name": "Vietnam"
            }
        }
    }
    </script>
    
    <!-- Critical CSS for above-the-fold content -->
    <style>
        /* Critical styles loaded inline for performance */
        :root {
            --primary-color: #6366f1;
            --primary-dark: #4f46e5;
            --secondary-color: #06b6d4;
            --accent-color: #f59e0b;
            --bg-primary: #ffffff;
            --bg-secondary: #f8fafc;
            --bg-tertiary: #f1f5f9;
            --text-primary: #0f172a;
            --text-secondary: #475569;
            --text-muted: #64748b;
            --border-color: #e2e8f0;
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
            --gradient-primary: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
            --gradient-secondary: linear-gradient(135deg, var(--accent-color) 0%, var(--primary-color) 100%);
        }

        /* Critical loading styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            line-height: 1.6;
            color: var(--text-primary);
            background: var(--bg-secondary);
            overflow-x: hidden;
        }

        /* Loading spinner for better UX */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            transition: opacity 0.5s ease-out;
        }

        .loading-spinner {
            width: 48px;
            height: 48px;
            border: 4px solid var(--border-color);
            border-top: 4px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            margin-top: 1rem;
            color: var(--text-secondary);
            font-size: 0.875rem;
        }

        /* Error boundary styles */
        .error-boundary {
            padding: 2rem;
            text-align: center;
            background: #fef2f2;
            border: 1px solid #fecaca;
            border-radius: 8px;
            margin: 1rem;
        }

        .error-boundary h2 {
            color: #dc2626;
            margin-bottom: 1rem;
        }

        .error-boundary p {
            color: #7f1d1d;
            margin-bottom: 1rem;
        }

        .error-boundary button {
            background: #dc2626;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
        }

        /* Performance optimization */
        img, video {
            max-width: 100%;
            height: auto;
        }

        /* Reduce motion for accessibility */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Focus states for accessibility */
        .n8n-chat button:focus,
        .n8n-chat input:focus {
            outline: 2px solid #6366f1 !important;
            outline-offset: 2px !important;
        }

        /* ====== PHASE 2: UX ENHANCEMENT ====== */
        
        /* Dark Mode Support */
        :root[data-theme="dark"] {
            --primary-color: #818cf8;
            --primary-dark: #6366f1;
            --secondary-color: #22d3ee;
            --accent-color: #fbbf24;
            --bg-primary: #1f2937;
            --bg-secondary: #111827;
            --bg-tertiary: #374151;
            --text-primary: #f9fafb;
            --text-secondary: #d1d5db;
            --text-muted: #9ca3af;
            --border-color: #374151;
        }

        /* Skeleton Loading Screens */
        .skeleton {
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: loading 1.5s infinite;
            border-radius: 4px;
        }

        :root[data-theme="dark"] .skeleton {
            background: linear-gradient(90deg, #374151 25%, #4b5563 50%, #374151 75%);
            background-size: 200% 100%;
        }

        @keyframes loading {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        .skeleton-header {
            height: 60px;
            margin-bottom: 1rem;
        }

        .skeleton-text {
            height: 16px;
            margin-bottom: 0.5rem;
        }

        .skeleton-text:last-child {
            width: 60%;
        }

        .skeleton-card {
            height: 200px;
            border-radius: 1rem;
        }

        .skeleton-chat {
            height: 600px;
            border-radius: 20px;
        }

        /* Enhanced Micro-interactions */
        .interactive-element {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            will-change: transform, box-shadow;
        }

        .interactive-element:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
        }

        .interactive-element:active {
            transform: translateY(0);
            transition-duration: 0.1s;
        }

        /* Advanced Button Hover Effects */
        .btn-enhanced {
            position: relative;
            overflow: hidden;
            background: var(--gradient-primary);
            border: none;
            color: white;
            padding: 12px 24px;
            border-radius: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-enhanced::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }

        .btn-enhanced:hover::before {
            left: 100%;
        }

        .btn-enhanced:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(99, 102, 241, 0.3);
        }

        /* Smooth Page Transitions */
        .page-transition {
            opacity: 0;
            transform: translateY(20px);
            animation: fadeInUp 0.8s ease-out forwards;
        }

        .page-transition:nth-child(1) { animation-delay: 0.1s; }
        .page-transition:nth-child(2) { animation-delay: 0.2s; }
        .page-transition:nth-child(3) { animation-delay: 0.3s; }

        /* Dark Mode Toggle */
        .theme-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 26px;
            background: var(--border-color);
            border-radius: 26px;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1001;
        }

        .theme-toggle::before {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        :root[data-theme="dark"] .theme-toggle {
            background: var(--primary-color);
        }

        :root[data-theme="dark"] .theme-toggle::before {
            transform: translateX(24px);
            background: #1f2937;
        }

        /* Enhanced Accessibility */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* Focus management for keyboard navigation */
        .focus-trap {
            outline: none;
        }

        .focus-visible {
            outline: 2px solid var(--primary-color);
            outline-offset: 2px;
        }

        /* High contrast mode support */
        @media (prefers-contrast: high) {
            :root {
                --border-color: #000000;
                --text-secondary: #000000;
            }
            
            :root[data-theme="dark"] {
                --border-color: #ffffff;
                --text-secondary: #ffffff;
            }
        }

        /* Reduced motion support */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
                scroll-behavior: auto !important;
            }
            
            .skeleton {
                animation: none;
                background: var(--border-color);
            }
        }

        /* Advanced Loading States */
        .loading-state {
            position: relative;
            overflow: hidden;
        }

        .loading-state::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .loading-state.is-loading::after {
            opacity: 1;
            pointer-events: all;
        }

        /* Smart Grid System */
        .smart-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(min(300px, 100%), 1fr));
            gap: 2rem;
            transition: all 0.3s ease;
        }

        /* Progressive Image Loading */
        .progressive-image {
            position: relative;
            overflow: hidden;
            background: var(--skeleton-bg);
        }

        .progressive-image img {
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .progressive-image img.loaded {
            opacity: 1;
        }

        /* Enhanced Tooltips */
        .tooltip {
            position: relative;
            cursor: help;
        }

        .tooltip::before {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--text-primary);
            color: var(--bg-primary);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .tooltip::after {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 5px solid transparent;
            border-top-color: var(--text-primary);
            opacity: 0;
            transition: all 0.3s ease;
        }

        .tooltip:hover::before,
        .tooltip:hover::after {
            opacity: 1;
            transform: translateX(-50%) translateY(-5px);
        }

        /* Notification System */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 16px 20px;
            box-shadow: var(--shadow-lg);
            max-width: 400px;
            transform: translateX(100%);
            transition: all 0.3s ease;
            z-index: 1002;
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.success {
            border-left: 4px solid #10b981;
        }

        .notification.error {
            border-left: 4px solid #ef4444;
        }

        .notification.warning {
            border-left: 4px solid #f59e0b;
        }

        .notification.info {
            border-left: 4px solid var(--primary-color);
        }

        /* Enhanced Chat Loading States */
        .chat-skeleton {
            padding: 20px 24px;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .chat-skeleton-message {
            display: flex;
            align-items: flex-start;
            gap: 8px;
        }

        .chat-skeleton-message.user {
            justify-content: flex-end;
        }

        .chat-skeleton-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
        }

        .chat-skeleton-bubble {
            height: 40px;
            border-radius: 18px;
            max-width: 70%;
        }

        .chat-skeleton-message.user .chat-skeleton-bubble {
            background: linear-gradient(90deg, #e0e7ff 25%, #c7d2fe 50%, #e0e7ff 75%);
        }

        /* Performance Optimizations */
        .will-change-transform {
            will-change: transform;
        }

        .will-change-opacity {
            will-change: opacity;
        }

        .gpu-accelerated {
            transform: translateZ(0);
            backface-visibility: hidden;
            perspective: 1000px;
        }

        /* Advanced Mobile Interactions */
        @media (max-width: 768px) {
            .touch-target {
                min-height: 44px;
                min-width: 44px;
            }

            .mobile-friendly {
                -webkit-tap-highlight-color: transparent;
                touch-action: manipulation;
            }

            /* Improved mobile scrolling */
            .smooth-scroll {
                -webkit-overflow-scrolling: touch;
                scroll-behavior: smooth;
            }
        }

        /* Smart Content Adaptation */
        @media (prefers-color-scheme: dark) {
            :root:not([data-theme]) {
                --primary-color: #818cf8;
                --bg-primary: #1f2937;
                --bg-secondary: #111827;
                --text-primary: #f9fafb;
                --text-secondary: #d1d5db;
                --border-color: #374151;
            }
        }

        /* Enhanced Error States */
        .error-state {
            padding: 2rem;
            text-align: center;
            background: #fef2f2;
            border: 1px solid #fecaca;
            border-radius: 12px;
            margin: 1rem 0;
        }

        :root[data-theme="dark"] .error-state {
            background: #451a1a;
            border-color: #7f1d1d;
        }

        .error-state .icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.8;
        }

        .error-state h3 {
            color: #dc2626;
            margin-bottom: 0.5rem;
            font-size: 1.25rem;
        }

        :root[data-theme="dark"] .error-state h3 {
            color: #f87171;
        }

        .error-state p {
            color: #7f1d1d;
            margin-bottom: 1rem;
            line-height: 1.6;
        }

        :root[data-theme="dark"] .error-state p {
            color: #fca5a5;
        }

        .retry-button {
            background: #dc2626;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .retry-button:hover {
            background: #b91c1c;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(220, 38, 38, 0.3);
        }

        #dark-mode-toggle:hover {
            transform: scale(1.1);
        }

        /* Advanced Status Indicator */
        .enterprise-status {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 500;
            z-index: 1000;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
            cursor: pointer;
            transition: all 0.3s ease;
            opacity: 0;
            transform: translateY(-10px);
            animation: fadeInStatus 0.8s ease forwards 3s;
        }

        .enterprise-status:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .enterprise-status .status-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            background: #10b981;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }

        @keyframes fadeInStatus {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Enhanced Chat Features Indicators */
        .quick-replies {
            animation: slideUp 0.5s ease forwards;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Performance Optimization Styles */
        .skeleton-loading {
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }

        @keyframes shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }

        /* Advanced Analytics Visual Enhancements */
        [data-debug="true"]::before {
            content: "🐛 DEBUG MODE";
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: #ff6b6b;
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 11px;
            z-index: 1000;
            animation: debugBlink 2s infinite;
        }

        @keyframes debugBlink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.5; }
        }

        /* Business Intelligence Visual Cues */
        .user-segment-indicator {
            position: fixed;
            bottom: 70px;
            right: 20px;
            background: rgba(99, 102, 241, 0.9);
            color: white;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 11px;
            z-index: 999;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        /* Security Indicator */
        .security-shield {
            position: fixed;
            top: 70px;
            right: 20px;
            width: 24px;
            height: 24px;
            opacity: 0.7;
            z-index: 999;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .security-shield:hover {
            opacity: 1;
            transform: scale(1.1);
        }

        /* Enterprise Grade Enhancements */
        body.enterprise-mode {
            --primary-color: #667eea;
            --accent-color: #764ba2;
        }

        .enterprise-mode .hero h1 {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* Voice Input Animation */
        .voice-button.recording {
            animation: voiceRecording 1s infinite;
        }

        @keyframes voiceRecording {
            0%, 100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            50% { transform: scale(1.05); box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
        }

        /* Advanced Loading States */
        .advanced-loading {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 3s ease-in-out infinite;
        }

        @keyframes gradientShift {
            0%, 100% { filter: hue-rotate(0deg); }
            50% { filter: hue-rotate(90deg); }
        }

        /* Memory Usage Indicator (for development) */
        .memory-indicator {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: #10b981;
            padding: 4px 8px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            z-index: 999;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .memory-indicator.show {
            opacity: 1;
        }

        /* Accessibility Enhancement Indicators */
        .accessibility-enabled .skip-link:focus {
            animation: accessibilityPulse 0.5s ease;
        }

        @keyframes accessibilityPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        /* High Contrast Mode Support */
        @media (prefers-contrast: high) {
            .hero {
                background: #000;
                color: #fff;
            }
            
            .card {
                border: 2px solid #fff;
                background: #000;
                color: #fff;
            }
        }

        /* Reduced Motion Support */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Print Styles for Reports */
        @media print {
            .enterprise-status,
            .security-shield,
            .memory-indicator,
            #dark-mode-toggle {
                display: none !important;
            }
            
            body {
                background: white !important;
                color: black !important;
            }
        }

        /* Notification System Styles */
        #notification-container {
            position: fixed;
            top: 80px;
            right: 20px;
            z-index: 10000;
            pointer-events: none;
        }

        .notification {
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            margin-bottom: 12px;
            max-width: 400px;
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.3s ease;
            pointer-events: all;
            border-left: 4px solid #3b82f6;
        }

        .notification.notification-success {
            border-left-color: #10b981;
        }

        .notification.notification-error {
            border-left-color: #ef4444;
        }

        .notification.notification-warning {
            border-left-color: #f59e0b;
        }

        .notification.notification-info {
            border-left-color: #3b82f6;
        }

        .notification-content {
            display: flex;
            align-items: center;
            padding: 16px;
            gap: 12px;
        }

        .notification-icon {
            font-size: 18px;
            flex-shrink: 0;
        }

        .notification-message {
            flex: 1;
            font-size: 14px;
            line-height: 1.4;
            color: #374151;
        }

        .notification-close {
            background: none;
            border: none;
            font-size: 18px;
            color: #9ca3af;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .notification-close:hover {
            background: #f3f4f6;
            color: #6b7280;
        }

        /* Notification animations */
        .notification {
            animation: slideInNotification 0.3s ease forwards;
        }

        @keyframes slideInNotification {
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        /* Screen reader only content */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* Dark theme for notifications */
        [data-theme="dark"] .notification {
            background: #1f2937;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        [data-theme="dark"] .notification-message {
            color: #e5e7eb;
        }

        [data-theme="dark"] .notification-close {
            color: #9ca3af;
        }

        [data-theme="dark"] .notification-close:hover {
            background: #374151;
            color: #d1d5db;
        }
    </style>
</head>
<body>
    <!-- Animated Background -->
    <div class="background-animation"></div>
    
    <!-- Dark Mode Toggle -->
    <button class="theme-toggle" id="theme-toggle" aria-label="Toggle dark mode" data-tooltip="Switch Theme">
        <span class="sr-only">Toggle between light and dark mode</span>
    </button>

    <!-- Enterprise Status Indicator -->
    <div class="enterprise-status" title="Enterprise Features Active" onclick="window.matthewAI?.getSystemStatus()">
        <span class="status-dot"></span>
        Enterprise
    </div>

    <!-- Security Shield Indicator -->
    <div class="security-shield" title="Security Monitoring Active" onclick="window.matthewAI?.runSecurityScan()">
        🛡️
    </div>
    
    <!-- Notification Container -->
    <div id="notification-container" aria-live="polite" aria-atomic="true"></div>
    
    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loading-overlay">
        <div>
            <div class="loading-spinner"></div>
            <div class="loading-text">Loading your AI assistant...</div>
        </div>
    </div>
    
    <!-- Floating Elements -->
    <div class="floating-elements">
        <div class="floating-element">🤖</div>
        <div class="floating-element">💡</div>
        <div class="floating-element">🚀</div>
    </div>

    <!-- Header -->
    <header class="header" role="banner">
        <div class="header-content">
            <div class="logo">Matthew.AI</div>
            <div class="status-indicator tooltip" data-tooltip="AI system is online and ready">
                <div class="status-dot" aria-hidden="true"></div>
                <span>AI Assistant Online</span>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <div class="container">
        <main class="main-content" role="main">
            <!-- Hero Section -->
            <div class="hero-badge page-transition">
                <span role="img" aria-label="Robot">🤖</span>
                <span>AI-Powered Digital Experience</span>
            </div>
            
            <h1 class="hero-title page-transition">Welcome to My Digital Space</h1>
            
            <p class="hero-subtitle page-transition">
                I'm Matthew, a tech enthusiast exploring the frontiers of AI and business innovation. 
                This space showcases my work, thoughts, and the intelligent systems I build. 
                Feel free to explore and chat with my AI assistant for any questions!
            </p>

            <!-- Features -->
            <div class="features smart-grid" role="region" aria-label="Key features">
                <div class="feature-card interactive-element page-transition" tabindex="0">
                    <span class="feature-icon" role="img" aria-label="Brain">🧠</span>
                    <h3 class="feature-title">Intelligent AI Assistant</h3>
                    <p class="feature-description">
                        Chat with my personal AI that knows everything about my work, experience, and projects. Available in English and Vietnamese.
                    </p>
                </div>
                
                <div class="feature-card interactive-element page-transition" tabindex="0">
                    <span class="feature-icon" role="img" aria-label="Books">📚</span>
                    <h3 class="feature-title">Knowledge Base</h3>
                    <p class="feature-description">
                        Powered by RAG technology, my AI can access and search through my complete portfolio of documents and projects.
                    </p>
                </div>
                
                <div class="feature-card interactive-element page-transition" tabindex="0">
                    <span class="feature-icon" role="img" aria-label="Rocket">🚀</span>
                    <h3 class="feature-title">Real-time Updates</h3>
                    <p class="feature-description">
                        The system automatically updates with new information, ensuring you always get the most current insights about my work.
                    </p>
                </div>
            </div>

            <!-- CTA Section -->
            <div class="cta-section page-transition">
                <p class="cta-text">
                    Ready to learn more? <span class="cta-highlight">Scroll down to chat</span> 
                    with my AI assistant or click the chat button to jump directly there!
                </p>
            </div>

            <!-- Scroll Indicator -->
            <div class="scroll-indicator" aria-hidden="true">
                <div>Scroll down to start chatting</div>
                <div class="scroll-arrow">↓</div>
            </div>
        </main>
    </div>

    <!-- Chat Section -->
    <section class="chat-section" id="chat-section" role="region" aria-labelledby="chat-title">
        <div class="chat-container">
            <div class="chat-header page-transition">
                <h2 class="chat-title" id="chat-title">Chat with My AI Assistant</h2>
                <p class="chat-subtitle">
                    Ask me anything about Matthew's work, experience, projects, or interests. 
                    I can answer in both English and Vietnamese! The conversation continues as you scroll.
                </p>
            </div>
            <div class="chat-widget-container loading-state" id="chat-widget-container" role="application" aria-label="AI Chat Interface">
                <!-- Initial skeleton loading screen -->
                <div class="chat-skeleton" id="chat-skeleton">
                    <div class="skeleton skeleton-header"></div>
                    <div class="chat-skeleton-message">
                        <div class="skeleton skeleton-avatar chat-skeleton-avatar"></div>
                        <div class="skeleton chat-skeleton-bubble" style="width: 60%;"></div>
                    </div>
                    <div class="chat-skeleton-message user">
                        <div class="skeleton chat-skeleton-bubble" style="width: 40%;"></div>
                    </div>
                    <div class="chat-skeleton-message">
                        <div class="skeleton skeleton-avatar chat-skeleton-avatar"></div>
                        <div class="skeleton chat-skeleton-bubble" style="width: 70%;"></div>
                    </div>
                    <div class="skeleton" style="height: 60px; border-radius: 30px; margin-top: auto;"></div>
                </div>
                <!-- Chat widget will be embedded here -->
            </div>
        </div>
    </section>

    <!-- Scroll to Chat Button -->
    <button class="scroll-to-chat interactive-element mobile-friendly touch-target" 
            id="scroll-to-chat" 
            aria-label="Scroll to chat section" 
            data-tooltip="Jump to Chat"
            onclick="scrollToChat()">
        <span role="img" aria-label="Chat">💬</span>
    </button>

    <!-- Chat Integration Script -->
    <script type="module">
        // ========================================
        // BULLETPROOF WEBSITE FRAMEWORK
        // Error Handling, Monitoring & Resilience
        // ========================================
        
        class WebsiteManager {
            constructor() {
                this.errors = [];
                this.performance = {};
                this.retryAttempts = new Map();
                this.maxRetries = 3;
                this.init();
            }
            
            init() {
                this.setupErrorHandling();
                this.setupPerformanceMonitoring();
                this.setupNetworkResilience();
                this.startHealthChecks();
                console.log('🛡️ Website protection systems activated');
            }
            
            // Global error handling
            setupErrorHandling() {
                // Catch unhandled JavaScript errors
                window.addEventListener('error', (event) => {
                    this.logError('JavaScript Error', {
                        message: event.message,
                        source: event.filename,
                        line: event.lineno,
                        column: event.colno,
                        stack: event.error?.stack
                    });
                });
                
                // Catch unhandled promise rejections
                window.addEventListener('unhandledrejection', (event) => {
                    this.logError('Unhandled Promise Rejection', {
                        reason: event.reason,
                        promise: event.promise
                    });
                    event.preventDefault(); // Prevent console spam
                });
                
                // Catch resource loading errors
                window.addEventListener('error', (event) => {
                    if (event.target !== window) {
                        this.logError('Resource Loading Error', {
                            element: event.target.tagName,
                            source: event.target.src || event.target.href,
                            message: 'Failed to load resource'
                        });
                        this.handleResourceError(event.target);
                    }
                }, true);
            }
            
            // Performance monitoring
            setupPerformanceMonitoring() {
                // Monitor Core Web Vitals
                this.observePerformance();
                
                // Track page load time
                window.addEventListener('load', () => {
                    const loadTime = performance.now();
                    this.performance.loadTime = loadTime;
                    console.log(`⚡ Page loaded in ${Math.round(loadTime)}ms`);
                    
                    if (loadTime > 3000) {
                        console.warn('⚠️ Slow page load detected');
                        this.optimizePerformance();
                    }
                });
            }
            
            // Network resilience
            setupNetworkResilience() {
                // Monitor network status
                window.addEventListener('online', () => {
                    console.log('🌐 Network connection restored');
                    this.handleNetworkRestore();
                });
                
                window.addEventListener('offline', () => {
                    console.warn('📴 Network connection lost');
                    this.handleNetworkLoss();
                });
                
                // Check connection quality
                if ('connection' in navigator) {
                    const connection = navigator.connection;
                    console.log(`📶 Connection: ${connection.effectiveType}, ${connection.downlink}Mbps`);
                }
            }
            
            // Health check system
            startHealthChecks() {
                setInterval(() => {
                    this.runHealthCheck();
                }, 30000); // Every 30 seconds
            }
            
            // Log errors with context
            logError(type, details) {
                const error = {
                    type,
                    details,
                    timestamp: new Date().toISOString(),
                    url: window.location.href,
                    userAgent: navigator.userAgent,
                    viewport: {
                        width: window.innerWidth,
                        height: window.innerHeight
                    }
                };
                
                this.errors.push(error);
                console.error(`🚨 ${type}:`, details);
                
                // Send to monitoring service (implement based on your needs)
                this.reportError(error);
            }
            
            // Handle resource loading failures
            handleResourceError(element) {
                const retryKey = element.src || element.href;
                const retryCount = this.retryAttempts.get(retryKey) || 0;
                
                if (retryCount < this.maxRetries) {
                    this.retryAttempts.set(retryKey, retryCount + 1);
                    console.log(`🔄 Retrying resource load (${retryCount + 1}/${this.maxRetries}): ${retryKey}`);
                    
                    // Retry with exponential backoff
                    setTimeout(() => {
                        if (element.tagName === 'SCRIPT') {
                            const newScript = document.createElement('script');
                            newScript.src = element.src;
                            newScript.type = element.type;
                            document.head.appendChild(newScript);
                        } else if (element.tagName === 'LINK') {
                            element.href = element.href + '?retry=' + (retryCount + 1);
                        }
                    }, Math.pow(2, retryCount) * 1000);
                } else {
                    console.error(`❌ Resource failed after ${this.maxRetries} attempts: ${retryKey}`);
                    this.provideFallback(element);
                }
            }
            
            // Provide fallbacks for failed resources
            provideFallback(element) {
                if (element.src && element.src.includes('n8n-chat')) {
                    console.log('🔄 Activating chat fallback system');
                    this.activateChatFallback();
                }
            }
            
            // Performance optimization
            optimizePerformance() {
                // Defer non-critical resources
                const nonCriticalImages = document.querySelectorAll('img[loading="lazy"]');
                nonCriticalImages.forEach(img => {
                    if (img.loading !== 'lazy') {
                        img.loading = 'lazy';
                    }
                });
                
                // Reduce animation if performance is poor
                if (this.performance.loadTime > 5000) {
                    document.documentElement.style.setProperty('--animation-duration', '0.1s');
                    console.log('🎨 Reduced animations for better performance');
                }
            }
            
            // Network status handlers
            handleNetworkRestore() {
                // Retry failed requests
                this.retryFailedOperations();
                this.showNetworkStatus('online');
            }
            
            handleNetworkLoss() {
                this.showNetworkStatus('offline');
                this.enableOfflineMode();
            }
            
            // Health check
            runHealthCheck() {
                const checks = {
                    chatWidget: this.checkChatWidget(),
                    domIntegrity: this.checkDOMIntegrity(),
                    memoryUsage: this.checkMemoryUsage(),
                    errorRate: this.checkErrorRate()
                };
                
                const failedChecks = Object.entries(checks).filter(([, passed]) => !passed);
                
                if (failedChecks.length > 0) {
                    console.warn('⚠️ Health check failed:', failedChecks.map(([check]) => check));
                    this.handleHealthCheckFailure(failedChecks);
                }
            }
            
            // Individual health checks
            checkChatWidget() {
                const chatContainer = document.querySelector('#chat-widget-container');
                return chatContainer && chatContainer.children.length > 0;
            }
            
            checkDOMIntegrity() {
                const criticalElements = ['header', 'main', '.chat-section'];
                return criticalElements.every(selector => document.querySelector(selector));
            }
            
            checkMemoryUsage() {
                if ('memory' in performance) {
                    const memory = performance.memory;
                    const usageRatio = memory.usedJSHeapSize / memory.jsHeapSizeLimit;
                    return usageRatio < 0.9; // Less than 90% memory usage
                }
                return true; // Can't check, assume OK
            }
            
            checkErrorRate() {
                const recentErrors = this.errors.filter(error => 
                    Date.now() - new Date(error.timestamp).getTime() < 300000 // Last 5 minutes
                );
                return recentErrors.length < 5; // Less than 5 errors in 5 minutes
            }
            
            // Handle health check failures
            handleHealthCheckFailure(failedChecks) {
                failedChecks.forEach(([check]) => {
                    switch (check) {
                        case 'chatWidget':
                            this.recoverChatWidget();
                            break;
                        case 'memoryUsage':
                            this.cleanupMemory();
                            break;
                        case 'errorRate':
                            this.resetErrorState();
                            break;
                    }
                });
            }
            
            // Recovery methods
            recoverChatWidget() {
                console.log('🔧 Attempting to recover chat widget...');
                setTimeout(() => {
                    if (!this.checkChatWidget()) {
                        this.activateChatFallback();
                    }
                }, 5000);
            }
            
            activateChatFallback() {
                console.log('🆘 Activating emergency chat fallback');
                window.createFallbackChat?.();
            }
            
            cleanupMemory() {
                // Clear old errors
                if (this.errors.length > 100) {
                    this.errors = this.errors.slice(-50);
                }
                
                // Force garbage collection if available
                if (window.gc) {
                    window.gc();
                }
            }
            
            resetErrorState() {
                this.errors = [];
                this.retryAttempts.clear();
                console.log('🔄 Error state reset');
            }
            
            // Utility methods
            showNetworkStatus(status) {
                const statusEl = document.querySelector('.network-status');
                if (statusEl) {
                    statusEl.textContent = status === 'online' ? 'Online' : 'Offline';
                    statusEl.className = `network-status ${status}`;
                }
            }
            
            enableOfflineMode() {
                document.body.classList.add('offline-mode');
                console.log('📴 Offline mode activated');
            }
            
            retryFailedOperations() {
                // Implementation for retrying failed operations
                console.log('🔄 Retrying failed operations...');
            }
            
            observePerformance() {
                // Web Vitals monitoring
                if ('PerformanceObserver' in window) {
                    const observer = new PerformanceObserver((list) => {
                        list.getEntries().forEach((entry) => {
                            console.log(`📊 ${entry.name}: ${Math.round(entry.value)}ms`);
                        });
                    });
                    
                    try {
                        observer.observe({ entryTypes: ['measure', 'navigation', 'paint'] });
                    } catch (e) {
                        console.log('Performance observer not fully supported');
                    }
                }
            }
            
            reportError(error) {
                // Send error to monitoring service
                // You can integrate with services like Sentry, LogRocket, etc.
                if (window.gtag) {
                    gtag('event', 'exception', {
                        description: error.type,
                        fatal: false
                    });
                }
            }
        }
        
        // Initialize website protection
        const websiteManager = new WebsiteManager();
        window.websiteManager = websiteManager; // Make available globally for debugging
        
        // ========================================
        // ENHANCED CHAT SYSTEM
        // ========================================
        
        // Import the n8n chat library
        import { createChat } from 'https://cdn.jsdelivr.net/npm/@n8n/chat/dist/chat.bundle.es.js';

        // Get the ngrok URL
        const ngrokUrl = 'https://505a-2405-4803-d738-6750-dcce-d1a4-a784-f659.ngrok-free.app';
        
        // Webhook ID from your n8n workflow
        const webhookId = '9e86df65-9069-444d-ae7a-15a8f4676abb';
        
        // Create the complete webhook URL
        const webhookUrl = `${ngrokUrl}/webhook/${webhookId}/chat`;

        // Function to scroll to chat
        window.scrollToChat = function() {
            document.getElementById('chat-section').scrollIntoView({ 
                behavior: 'smooth',
                block: 'start'
            });
        };

        // Initialize the chat widget in embedded mode
        createChat({
            // Embedded mode instead of popup
            mode: 'embed',
            target: '#chat-widget-container',

            // Webhook configuration
            webhookUrl: webhookUrl,

            // Initial welcome messages - bilingual support
            initialMessages: [
                "👋 Hello! I'm Matthew's AI assistant. I can chat in English or Vietnamese (Tôi có thể nói tiếng Việt). What would you like to know about Matthew?"
            ],

            // Chat configuration
            showWelcomeScreen: false,
            loadPreviousSession: true,
            
            // Enhanced styling for embedded mode
            theme: {
                primaryColor: '#6366f1',
                textColor: '#1f2937',
                backgroundColor: '#ffffff',
                borderRadius: '20px',
                fontSize: '16px',
                fontFamily: 'Inter, system-ui, sans-serif'
            }
        });

        // Monitor chat loading with multiple checks
        let chatLoadAttempts = 0;
        const maxAttempts = 10;
        
        function checkChatLoaded() {
            chatLoadAttempts++;
            console.log(`🔍 Checking chat load attempt ${chatLoadAttempts}/${maxAttempts}`);
            
            const chatContainer = document.querySelector('#chat-widget-container');
            const inputFields = chatContainer?.querySelectorAll('input, textarea, [contenteditable]');
            const buttons = chatContainer?.querySelectorAll('button');
            const chatContent = chatContainer?.children?.length > 0;
            
            console.log('🔍 Debug Info:');
            console.log('Chat container:', chatContainer);
            console.log('Chat has content:', chatContent);
            console.log('Input fields found:', inputFields?.length || 0);
            console.log('Buttons found:', buttons?.length || 0);
            
            if (chatContent && chatContainer) {
                console.log('✅ Chat widget content detected');
                
                // Make sure all inputs are visible
                inputFields?.forEach((input, index) => {
                    console.log(`Making input ${index} visible:`, input);
                    input.style.display = 'block';
                    input.style.visibility = 'visible';
                    input.style.opacity = '1';
                });
                
                buttons?.forEach((button, index) => {
                    console.log(`Making button ${index} visible:`, button);
                    button.style.display = 'flex';
                    button.style.visibility = 'visible';
                    button.style.opacity = '1';
                });
                
                // If no input field found after widget loads, create fallback
                if (!inputFields || inputFields.length === 0) {
                    console.log('⚠️ No input field detected in loaded widget, creating fallback...');
                    setTimeout(() => createFallbackInput(chatContainer), 500);
                }
                
                return true; // Chat loaded successfully
            } else if (chatLoadAttempts >= maxAttempts) {
                console.error('❌ Chat widget failed to load after maximum attempts');
                createFallbackChat();
                return true; // Stop checking
            } else {
                // Continue checking
                setTimeout(checkChatLoaded, 1000);
                return false;
            }
        }
        
        // Start checking after initial delay
        setTimeout(checkChatLoaded, 2000);

        // Function to create a fallback input if n8n doesn't load properly
        function createFallbackInput(container) {
            if (!container) return;
            
            // Check if fallback already exists
            if (container.querySelector('.fallback-input')) return;
            
            const fallbackHTML = `
                <div class="fallback-input" style="
                    position: absolute;
                    bottom: 0;
                    left: 0;
                    right: 0;
                    background: white;
                    padding: 20px 24px;
                    border-top: 1px solid #e5e7eb;
                    display: flex;
                    align-items: center;
                    gap: 12px;
                    z-index: 1000;
                ">
                    <input type="text" placeholder="Type your message here..." style="
                        flex: 1;
                        padding: 12px 16px;
                        border: 2px solid #e5e7eb;
                        border-radius: 24px;
                        font-size: 15px;
                        font-family: 'Inter', sans-serif;
                        outline: none;
                        background: #f9fafb;
                        color: #1f2937;
                        min-height: 44px;
                    ">
                    <button type="button" style="
                        width: 44px;
                        height: 44px;
                        border-radius: 50%;
                        background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%);
                        border: none;
                        color: white;
                        cursor: pointer;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 16px;
                    ">➤</button>
                </div>
            `;
            
            container.insertAdjacentHTML('beforeend', fallbackHTML);
            
            // Add functionality to fallback input
            const input = container.querySelector('.fallback-input input');
            const button = container.querySelector('.fallback-input button');
            
            function sendMessage() {
                const message = input.value.trim();
                if (message) {
                    console.log('📤 Sending message via fallback:', message);
                    // Here you could implement direct API calls to your webhook
                    alert(`Message sent: ${message}\n\nNote: This is a fallback interface. The n8n chat widget didn't load properly.`);
                    input.value = '';
                }
            }
            
            button.addEventListener('click', sendMessage);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });
            
            input.addEventListener('focus', () => {
                input.style.borderColor = '#6366f1';
                input.style.background = 'white';
                input.style.boxShadow = '0 0 0 3px rgba(99, 102, 241, 0.1)';
            });
            
            input.addEventListener('blur', () => {
                input.style.borderColor = '#e5e7eb';
                input.style.background = '#f9fafb';
                input.style.boxShadow = 'none';
            });
        }

        // Function to create a complete fallback chat interface
        function createFallbackChat() {
            const container = document.querySelector('#chat-widget-container');
            if (!container) return;
            
            container.innerHTML = `
                <div style="
                    height: 600px;
                    background: white;
                    border-radius: 20px;
                    display: flex;
                    flex-direction: column;
                    border: 2px solid #e5e7eb;
                ">
                    <div style="
                        background: linear-gradient(135deg, #6366f1 0%, #06b6d4 100%);
                        padding: 20px 24px;
                        color: white;
                        border-radius: 20px 20px 0 0;
                    ">
                        <h3 style="margin: 0; font-size: 18px; font-weight: 600;">Matthew's AI Assistant</h3>
                        <p style="margin: 4px 0 0 0; font-size: 14px; opacity: 0.9;">Fallback Mode - Chat Widget Loading Issue</p>
                    </div>
                    
                    <div style="
                        flex: 1;
                        padding: 20px 24px;
                        background: #f8fafc;
                        overflow-y: auto;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        text-align: center;
                        color: #6b7280;
                    ">
                        <div>
                            <div style="font-size: 48px; margin-bottom: 16px;">🤖</div>
                            <h4 style="margin: 0 0 8px 0; color: #1f2937;">Chat Widget Loading...</h4>
                            <p style="margin: 0; font-size: 14px;">If this persists, please refresh the page or contact support.</p>
                        </div>
                    </div>
                    
                    <div style="
                        background: white;
                        padding: 20px 24px;
                        border-top: 1px solid #e5e7eb;
                        display: flex;
                        align-items: center;
                        gap: 12px;
                        border-radius: 0 0 20px 20px;
                    ">
                        <input type="text" placeholder="Type your message here..." style="
                            flex: 1;
                            padding: 12px 16px;
                            border: 2px solid #e5e7eb;
                            border-radius: 24px;
                            font-size: 15px;
                            font-family: 'Inter', sans-serif;
                            outline: none;
                            background: #f9fafb;
                            color: #1f2937;
                            min-height: 44px;
                        ">
                        <button type="button" style="
                            width: 44px;
                            height: 44px;
                            border-radius: 50%;
                            background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%);
                            border: none;
                            color: white;
                            cursor: pointer;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            font-size: 16px;
                        ">➤</button>
                    </div>
                </div>
            `;
            
            // Add functionality
            const input = container.querySelector('input');
            const button = container.querySelector('button');
            
            function sendMessage() {
                const message = input.value.trim();
                if (message) {
                    alert(`Message: ${message}\n\nNote: This is a fallback interface. Please refresh the page to try loading the full chat widget again.`);
                    input.value = '';
                }
            }
            
            button.addEventListener('click', sendMessage);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });
        }

        // Handle scroll to show/hide chat button
        document.addEventListener('DOMContentLoaded', function() {
            // ========================================
            // PHASE 2: ADVANCED UX FEATURES
            // ========================================
            
            // Initialize all UX systems
            initializeUXSystems();
            
            function initializeUXSystems() {
                setupDarkModeToggle();
                setupNotificationSystem();
                setupLoadingManager();
                setupAccessibilityFeatures();
                setupProgressiveEnhancement();
                setupChatEnhancements();
                console.log('🎨 Advanced UX systems initialized');
            }
            
            // Dark Mode Toggle System
            function setupDarkModeToggle() {
                const themeToggle = document.getElementById('theme-toggle');
                const root = document.documentElement;
                
                // Check for saved theme preference or default to system preference
                const savedTheme = localStorage.getItem('theme');
                const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                const initialTheme = savedTheme || (systemPrefersDark ? 'dark' : 'light');
                
                // Apply initial theme
                setTheme(initialTheme);
                
                // Toggle functionality
                themeToggle.addEventListener('click', () => {
                    const currentTheme = root.getAttribute('data-theme');
                    const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
                    setTheme(newTheme);
                    showNotification(`Switched to ${newTheme} mode`, 'info');
                });
                
                // Listen for system theme changes
                window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
                    if (!localStorage.getItem('theme')) {
                        setTheme(e.matches ? 'dark' : 'light');
                    }
                });
                
                function setTheme(theme) {
                    root.setAttribute('data-theme', theme);
                    localStorage.setItem('theme', theme);
                    
                    // Update theme toggle accessibility
                    themeToggle.setAttribute('aria-label', 
                        theme === 'dark' ? 'Switch to light mode' : 'Switch to dark mode'
                    );
                }
            }
            
            // Notification System
            function setupNotificationSystem() {
                window.showNotification = function(message, type = 'info', duration = 4000) {
                    const container = document.getElementById('notification-container');
                    const notification = document.createElement('div');
                    notification.className = `notification ${type}`;
                    notification.innerHTML = `
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <span style="font-size: 1.2em;">${getNotificationIcon(type)}</span>
                            <span>${message}</span>
                            <button onclick="this.parentElement.parentElement.remove()" 
                                    style="margin-left: auto; background: none; border: none; font-size: 1.2em; cursor: pointer;"
                                    aria-label="Close notification">×</button>
                        </div>
                    `;
                    
                    container.appendChild(notification);
                    
                    // Trigger animation
                    setTimeout(() => notification.classList.add('show'), 100);
                    
                    // Auto-remove
                    setTimeout(() => {
                        notification.classList.remove('show');
                        setTimeout(() => notification.remove(), 300);
                    }, duration);
                    
                    return notification;
                };
                
                function getNotificationIcon(type) {
                    const icons = {
                        success: '✅',
                        error: '❌',
                        warning: '⚠️',
                        info: 'ℹ️'
                    };
                    return icons[type] || icons.info;
                }
            }
            
            // Enhanced Loading Manager
            function setupLoadingManager() {
                const loadingOverlay = document.getElementById('loading-overlay');
                const chatSkeleton = document.getElementById('chat-skeleton');
                
                window.showLoading = function(message = 'Loading...') {
                    loadingOverlay.style.display = 'flex';
                    loadingOverlay.querySelector('.loading-text').textContent = message;
                };
                
                window.hideLoading = function() {
                    loadingOverlay.style.opacity = '0';
                    setTimeout(() => {
                        loadingOverlay.style.display = 'none';
                        loadingOverlay.style.opacity = '1';
                    }, 500);
                };
                
                window.showChatSkeleton = function() {
                    if (chatSkeleton) chatSkeleton.style.display = 'flex';
                };
                
                window.hideChatSkeleton = function() {
                    if (chatSkeleton) {
                        chatSkeleton.style.opacity = '0';
                        setTimeout(() => chatSkeleton.remove(), 300);
                    }
                };
                
                // Auto-hide loading after page loads
                window.addEventListener('load', () => {
                    setTimeout(() => hideLoading(), 1000);
                });
            }
            
            // Accessibility Features
            function setupAccessibilityFeatures() {
                // Keyboard navigation for feature cards
                const interactiveElements = document.querySelectorAll('.interactive-element');
                interactiveElements.forEach(element => {
                    if (element.tabIndex === 0) {
                        element.addEventListener('keydown', (e) => {
                            if (e.key === 'Enter' || e.key === ' ') {
                                e.preventDefault();
                                element.click();
                            }
                        });
                    }
                });
                
                // Focus management
                setupFocusManagement();
                
                // Skip to content link
                addSkipToContentLink();
                
                // Announce dynamic content changes
                setupLiveRegions();
            }
            
            function setupFocusManagement() {
                // Trap focus in modals/dialogs when needed
                let focusableElements = 'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])';
                
                window.trapFocus = function(element) {
                    const focusable = element.querySelectorAll(focusableElements);
                    const firstFocusable = focusable[0];
                    const lastFocusable = focusable[focusable.length - 1];
                    
                    element.addEventListener('keydown', (e) => {
                        if (e.key === 'Tab') {
                            if (e.shiftKey) {
                                if (document.activeElement === firstFocusable) {
                                    lastFocusable.focus();
                                    e.preventDefault();
                                }
                            } else {
                                if (document.activeElement === lastFocusable) {
                                    firstFocusable.focus();
                                    e.preventDefault();
                                }
                            }
                        }
                    });
                    
                    firstFocusable.focus();
                };
            }
            
            function addSkipToContentLink() {
                const skipLink = document.createElement('a');
                skipLink.href = '#chat-section';
                skipLink.textContent = 'Skip to chat';
                skipLink.className = 'sr-only';
                skipLink.style.cssText = `
                    position: fixed;
                    top: -40px;
                    left: 6px;
                    background: var(--primary-color);
                    color: white;
                    padding: 8px;
                    text-decoration: none;
                    border-radius: 4px;
                    z-index: 9999;
                    transition: top 0.3s;
                `;
                
                skipLink.addEventListener('focus', () => {
                    skipLink.style.top = '6px';
                });
                
                skipLink.addEventListener('blur', () => {
                    skipLink.style.top = '-40px';
                });
                
                document.body.insertBefore(skipLink, document.body.firstChild);
            }
            
            function setupLiveRegions() {
                // Announce when chat loads
                const chatContainer = document.getElementById('chat-widget-container');
                const observer = new MutationObserver((mutations) => {
                    mutations.forEach((mutation) => {
                        if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
                            // Check if chat widget was added
                            const hasChat = Array.from(mutation.addedNodes).some(node => 
                                node.nodeType === 1 && (node.classList.contains('n8n-chat') || node.querySelector('.n8n-chat'))
                            );
                            
                            if (hasChat) {
                                announceToScreenReader('Chat assistant is now ready');
                            }
                        }
                    });
                });
                
                observer.observe(chatContainer, { childList: true, subtree: true });
                
                window.announceToScreenReader = function(message) {
                    const announcement = document.createElement('div');
                    announcement.setAttribute('aria-live', 'polite');
                    announcement.setAttribute('aria-atomic', 'true');
                    announcement.className = 'sr-only';
                    announcement.textContent = message;
                    
                    document.body.appendChild(announcement);
                    setTimeout(() => announcement.remove(), 2000);
                };
            }
            
            // Progressive Enhancement
            function setupProgressiveEnhancement() {
                // Add enhanced interactions only if supported
                if ('IntersectionObserver' in window) {
                    setupScrollAnimations();
                }
                
                if ('requestIdleCallback' in window) {
                    requestIdleCallback(optimizePerformance);
                } else {
                    setTimeout(optimizePerformance, 2000);
                }
                
                // Add enhanced features based on capabilities
                if ('matchMedia' in window) {
                    setupResponsiveEnhancements();
                }
            }
            
            function setupScrollAnimations() {
                const observerOptions = {
                    threshold: 0.1,
                    rootMargin: '0px 0px -50px 0px'
                };
                
                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            entry.target.style.animationPlayState = 'running';
                            entry.target.classList.add('animate-in');
                        }
                    });
                }, observerOptions);
                
                document.querySelectorAll('.page-transition').forEach(el => {
                    observer.observe(el);
                });
            }
            
            function optimizePerformance() {
                // Add lazy loading to images
                const images = document.querySelectorAll('img:not([loading])');
                images.forEach(img => {
                    img.loading = 'lazy';
                });
                
                // Preload critical resources
                const criticalResources = [
                    'https://cdn.jsdelivr.net/npm/@n8n/chat/dist/chat.bundle.es.js'
                ];
                
                criticalResources.forEach(url => {
                    const link = document.createElement('link');
                    link.rel = 'preload';
                    link.as = 'script';
                    link.href = url;
                    document.head.appendChild(link);
                });
            }
            
            function setupResponsiveEnhancements() {
                // Add touch-friendly features on mobile
                const mobileQuery = window.matchMedia('(max-width: 768px)');
                
                function handleMobileChange(e) {
                    const isMobile = e.matches;
                    document.body.classList.toggle('is-mobile', isMobile);
                    
                    if (isMobile) {
                        // Enhanced mobile interactions
                        document.addEventListener('touchstart', () => {}, { passive: true });
                    }
                }
                
                mobileQuery.addListener(handleMobileChange);
                handleMobileChange(mobileQuery);
            }
            
            // Enhanced Chat Integration
            function setupChatEnhancements() {
                let chatLoadStartTime = Date.now();
                
                // Override the original chat monitoring with enhanced version
                window.originalCheckChatLoaded = window.checkChatLoaded;
                
                // Enhanced chat monitoring
                function enhancedChatMonitoring() {
                    const chatContainer = document.querySelector('#chat-widget-container');
                    
                    if (chatContainer) {
                        // Show skeleton while loading
                        showChatSkeleton();
                        
                        // Monitor for successful load
                        const chatObserver = new MutationObserver((mutations) => {
                            mutations.forEach((mutation) => {
                                if (mutation.addedNodes.length > 0) {
                                    const hasRealChat = Array.from(mutation.addedNodes).some(node =>
                                        node.nodeType === 1 && 
                                        (node.classList?.contains('n8n-chat') || node.querySelector?.('.n8n-chat'))
                                    );
                                    
                                    if (hasRealChat) {
                                        onChatLoaded();
                                        chatObserver.disconnect();
                                    }
                                }
                            });
                        });
                        
                        chatObserver.observe(chatContainer, { childList: true, subtree: true });
                        
                        // Fallback timeout
                        setTimeout(() => {
                            if (document.getElementById('chat-skeleton')) {
                                console.warn('Chat loading timeout, showing fallback');
                                window.createFallbackChat?.();
                                onChatLoaded();
                            }
                            chatObserver.disconnect();
                        }, 15000);
                    }
                }
                
                function onChatLoaded() {
                    const loadTime = Date.now() - chatLoadStartTime;
                    console.log(`💬 Chat loaded in ${loadTime}ms`);
                    
                    hideChatSkeleton();
                    announceToScreenReader('Chat assistant loaded successfully');
                    showNotification('Chat assistant is ready!', 'success');
                    
                    // Apply enhanced styling to chat
                    setTimeout(applyChatEnhancements, 500);
                }
                
                function applyChatEnhancements() {
                    const chatWidget = document.querySelector('.n8n-chat');
                    if (chatWidget) {
                        chatWidget.classList.add('gpu-accelerated');
                        
                        // Add accessibility improvements
                        const inputField = chatWidget.querySelector('input, textarea');
                        if (inputField) {
                            inputField.setAttribute('aria-label', 'Type your message to Matthew\'s AI assistant');
                            inputField.setAttribute('placeholder', 'Ask me anything about Matthew...');
                        }
                        
                        const sendButton = chatWidget.querySelector('button');
                        if (sendButton) {
                            sendButton.setAttribute('aria-label', 'Send message to AI assistant');
                        }
                    }
                }
                
                // Start enhanced monitoring
                enhancedChatMonitoring();
            }

            // Handle scroll to show/hide chat button
            const scrollButton = document.getElementById('scroll-to-chat');
            const chatSection = document.getElementById('chat-section');
            
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        // Chat section is visible, hide the scroll button
                        document.body.classList.add('chat-visible');
                    } else {
                        // Chat section is not visible, show the scroll button
                        document.body.classList.remove('chat-visible');
                    }
                });
            }, {
                threshold: 0.3
            });

            observer.observe(chatSection);

            // Header scroll effect
            let lastScrollTop = 0;
            const header = document.querySelector('.header');
            
            window.addEventListener('scroll', function() {
                let scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                
                if (scrollTop > lastScrollTop && scrollTop > 100) {
                    header.style.transform = 'translateY(-100%)';
                } else {
                    header.style.transform = 'translateY(0)';
                }
                
                lastScrollTop = scrollTop;
            });

            // Add loading class after page load
            setTimeout(() => {
                document.body.classList.add('loading');
            }, 100);

            // Parallax effect for floating elements
            window.addEventListener('scroll', function() {
                const scrolled = window.pageYOffset;
                const parallax = document.querySelectorAll('.floating-element');
                const speed = 0.5;

                parallax.forEach(element => {
                    const yPos = -(scrolled * speed);
                    element.style.transform = `translateY(${yPos}px)`;
                });
            });

            // Intersection Observer for animations
            const observerOptions = {
                threshold: 0.1,
                rootMargin: '0px 0px -50px 0px'
            };

            const cardObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.style.animationPlayState = 'running';
                    }
                });
            }, observerOptions);

            // Observe feature cards
            document.querySelectorAll('.feature-card').forEach(card => {
                cardObserver.observe(card);
            });
        });

        // Console welcome message
        console.log(`
        🤖 Welcome to Matthew's AI-Powered Portfolio!
        
        Built with:
        • n8n for workflow automation
        • RAG (Retrieval-Augmented Generation) for intelligent responses
        • Modern responsive web design
        • Large embedded chat interface with accessibility features
        • Real-time AI chat integration with loading animations
        
        Scroll down to chat with the AI and learn more about Matthew's work!
        `);

        // ========================================
        // PHASE 1 & 2: FOUNDATION SYSTEMS
        // ========================================
        
        // Health Monitoring System
        class HealthMonitor {
            constructor() {
                this.status = 'initializing';
                this.checks = new Map();
                this.lastCheck = null;
                this.init();
            }
            
            init() {
                this.status = 'healthy';
                this.startHealthChecks();
                console.log('💚 Health monitoring system initialized');
            }
            
            startHealthChecks() {
                setInterval(() => {
                    this.runHealthCheck();
                }, 30000); // Every 30 seconds
            }
            
            runHealthCheck() {
                const checks = {
                    timestamp: Date.now(),
                    dom: document.querySelector('body') !== null,
                    chat: document.querySelector('#chat-widget-container') !== null,
                    memory: this.checkMemoryUsage(),
                    performance: performance.now() > 0
                };
                
                this.checks.set(Date.now(), checks);
                this.lastCheck = checks;
                
                const healthy = Object.values(checks).every(check => 
                    typeof check === 'boolean' ? check : true
                );
                
                this.status = healthy ? 'healthy' : 'warning';
                
                if (!healthy) {
                    console.warn('⚠️ Health check failed:', checks);
                }
            }
            
            checkMemoryUsage() {
                if ('memory' in performance) {
                    const memory = performance.memory;
                    return memory.usedJSHeapSize / memory.jsHeapSizeLimit < 0.9;
                }
                return true;
            }
            
            getHealthReport() {
                return {
                    status: this.status,
                    lastCheck: this.lastCheck,
                    uptime: Date.now() - (this.checks.keys().next().value || Date.now()),
                    totalChecks: this.checks.size
                };
            }
        }
        
        // Error Handler System
        class ErrorHandler {
            constructor() {
                this.errors = [];
                this.maxErrors = 100;
                this.init();
            }
            
            init() {
                this.setupGlobalErrorHandling();
                console.log('🛡️ Error handling system initialized');
            }
            
            setupGlobalErrorHandling() {
                window.addEventListener('error', (event) => {
                    this.logError('JavaScript Error', {
                        message: event.message,
                        source: event.filename,
                        line: event.lineno,
                        column: event.colno,
                        stack: event.error?.stack
                    });
                });
                
                window.addEventListener('unhandledrejection', (event) => {
                    this.logError('Promise Rejection', {
                        reason: event.reason
                    });
                });
            }
            
            logError(type, details) {
                const error = {
                    type,
                    details,
                    timestamp: Date.now(),
                    url: window.location.href
                };
                
                this.errors.push(error);
                
                // Keep only recent errors
                if (this.errors.length > this.maxErrors) {
                    this.errors = this.errors.slice(-this.maxErrors);
                }
                
                console.error(`🚨 ${type}:`, details);
            }
            
            getErrors() {
                return this.errors.slice(-10); // Return last 10 errors
            }
        }
        
        // Notification System
        class NotificationSystem {
            constructor() {
                this.container = null;
                this.notifications = [];
                this.init();
            }
            
            init() {
                this.container = document.getElementById('notification-container');
                if (!this.container) {
                    this.createContainer();
                }
                console.log('🔔 Notification system initialized');
            }
            
            createContainer() {
                this.container = document.createElement('div');
                this.container.id = 'notification-container';
                this.container.setAttribute('aria-live', 'polite');
                this.container.setAttribute('aria-atomic', 'true');
                document.body.appendChild(this.container);
            }
            
            show(message, type = 'info', duration = 5000) {
                const notification = document.createElement('div');
                notification.className = `notification notification-${type}`;
                notification.innerHTML = `
                    <div class="notification-content">
                        <span class="notification-icon">${this.getIcon(type)}</span>
                        <span class="notification-message">${message}</span>
                        <button class="notification-close" onclick="this.parentElement.parentElement.remove()">×</button>
                    </div>
                `;
                
                this.container.appendChild(notification);
                this.notifications.push(notification);
                
                // Auto remove
                if (duration > 0) {
                    setTimeout(() => {
                        if (notification.parentElement) {
                            notification.remove();
                        }
                    }, duration);
                }
                
                return notification;
            }
            
            getIcon(type) {
                const icons = {
                    success: '✅',
                    error: '❌',
                    warning: '⚠️',
                    info: 'ℹ️'
                };
                return icons[type] || icons.info;
            }
        }
        
        // Loading System
        class LoadingSystem {
            constructor() {
                this.overlay = null;
                this.isLoading = false;
                this.init();
            }
            
            init() {
                this.overlay = document.getElementById('loading-overlay');
                console.log('⏳ Loading system initialized');
            }
            
            show(message = 'Loading...') {
                if (this.overlay) {
                    const textElement = this.overlay.querySelector('.loading-text');
                    if (textElement) {
                        textElement.textContent = message;
                    }
                    this.overlay.style.display = 'flex';
                    this.isLoading = true;
                }
            }
            
            hide() {
                if (this.overlay) {
                    this.overlay.style.display = 'none';
                    this.isLoading = false;
                }
            }
            
            getStatus() {
                return { isLoading: this.isLoading };
            }
        }
        
        // Theme Manager
        class ThemeManager {
            constructor() {
                this.currentTheme = 'auto';
                this.systemTheme = 'light';
                this.init();
            }
            
            init() {
                this.detectSystemTheme();
                this.loadSavedTheme();
                this.setupThemeToggle();
                this.applyTheme();
                console.log('🎨 Theme management system initialized');
            }
            
            detectSystemTheme() {
                if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                    this.systemTheme = 'dark';
                } else {
                    this.systemTheme = 'light';
                }
                
                // Listen for system theme changes
                window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
                    this.systemTheme = e.matches ? 'dark' : 'light';
                    if (this.currentTheme === 'auto') {
                        this.applyTheme();
                    }
                });
            }
            
            loadSavedTheme() {
                const saved = localStorage.getItem('theme');
                if (saved && ['light', 'dark', 'auto'].includes(saved)) {
                    this.currentTheme = saved;
                }
            }
            
            setupThemeToggle() {
                const toggle = document.getElementById('theme-toggle');
                if (toggle) {
                    toggle.addEventListener('click', () => {
                        this.toggleTheme();
                    });
                }
            }
            
            toggleTheme() {
                const themes = ['light', 'dark', 'auto'];
                const currentIndex = themes.indexOf(this.currentTheme);
                const nextIndex = (currentIndex + 1) % themes.length;
                this.setTheme(themes[nextIndex]);
            }
            
            setTheme(theme) {
                if (['light', 'dark', 'auto'].includes(theme)) {
                    this.currentTheme = theme;
                    localStorage.setItem('theme', theme);
                    this.applyTheme();
                }
            }
            
            applyTheme() {
                const effectiveTheme = this.currentTheme === 'auto' ? this.systemTheme : this.currentTheme;
                
                if (effectiveTheme === 'dark') {
                    document.documentElement.setAttribute('data-theme', 'dark');
                } else {
                    document.documentElement.setAttribute('data-theme', 'light');
                }
                
                // Update toggle icon
                const toggle = document.getElementById('theme-toggle');
                if (toggle) {
                    const icons = {
                        light: '🌙',
                        dark: '☀️',
                        auto: '🌓'
                    };
                    toggle.textContent = icons[this.currentTheme] || '🌙';
                }
            }
            
            getCurrentTheme() {
                return {
                    current: this.currentTheme,
                    effective: this.currentTheme === 'auto' ? this.systemTheme : this.currentTheme,
                    system: this.systemTheme
                };
            }
        }
        
        // Accessibility Manager
        class AccessibilityManager {
            constructor() {
                this.features = {
                    keyboardNavigation: false,
                    screenReader: false,
                    highContrast: false,
                    reducedMotion: false
                };
                this.init();
            }
            
            init() {
                this.detectAccessibilityFeatures();
                this.setupKeyboardNavigation();
                this.setupFocusManagement();
                this.setupScreenReaderSupport();
                console.log('♿ Accessibility management system initialized');
            }
            
            detectAccessibilityFeatures() {
                // Detect reduced motion preference
                if (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                    this.features.reducedMotion = true;
                    document.body.classList.add('reduced-motion');
                }
                
                // Detect high contrast preference
                if (window.matchMedia && window.matchMedia('(prefers-contrast: high)').matches) {
                    this.features.highContrast = true;
                    document.body.classList.add('high-contrast');
                }
            }
            
            setupKeyboardNavigation() {
                // Enable keyboard navigation
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Tab') {
                        this.features.keyboardNavigation = true;
                        document.body.classList.add('keyboard-navigation');
                    }
                    
                    // Skip links
                    if (e.key === 'Enter' && e.target.classList.contains('skip-link')) {
                        e.preventDefault();
                        const target = document.querySelector(e.target.getAttribute('href'));
                        if (target) {
                            target.focus();
                        }
                    }
                });
                
                // Detect mouse usage
                document.addEventListener('mousedown', () => {
                    document.body.classList.remove('keyboard-navigation');
                });
            }
            
            setupFocusManagement() {
                // Enhance focus visibility
                document.addEventListener('focusin', (e) => {
                    if (e.target.tagName && !e.target.hasAttribute('tabindex')) {
                        e.target.setAttribute('data-focused', 'true');
                    }
                });
                
                document.addEventListener('focusout', (e) => {
                    if (e.target.hasAttribute('data-focused')) {
                        e.target.removeAttribute('data-focused');
                    }
                });
            }
            
            setupScreenReaderSupport() {
                // Add screen reader announcements for dynamic content
                const announceToScreenReader = (message) => {
                    const announcement = document.createElement('div');
                    announcement.setAttribute('aria-live', 'polite');
                    announcement.setAttribute('aria-atomic', 'true');
                    announcement.className = 'sr-only';
                    announcement.textContent = message;
                    document.body.appendChild(announcement);
                    
                    setTimeout(() => {
                        document.body.removeChild(announcement);
                    }, 1000);
                };
                
                window.announceToScreenReader = announceToScreenReader;
            }
            
            getStatus() {
                return {
                    features: this.features,
                    isKeyboardUser: document.body.classList.contains('keyboard-navigation'),
                    reducedMotion: this.features.reducedMotion,
                    highContrast: this.features.highContrast
                };
            }
        }

        // ========================================
        // PHASE 3: ADVANCED FEATURES & INTELLIGENCE
        // ========================================
        
        class AdvancedFeaturesManager {
            constructor() {
                this.analytics = new AnalyticsManager();
                this.chatEnhancer = new ChatEnhancer();
                this.performanceMonitor = new PerformanceMonitor();
                this.securityManager = new SecurityManager();
                this.businessIntelligence = new BusinessIntelligence();
                this.init();
            }
            
            init() {
                console.log('🚀 Initializing Phase 3: Advanced Features');
                this.analytics.init();
                this.chatEnhancer.init();
                this.performanceMonitor.init();
                this.securityManager.init();
                this.businessIntelligence.init();
                console.log('✨ Enterprise-level features activated');
            }
        }
        
        // Advanced Analytics System
        class AnalyticsManager {
            constructor() {
                this.events = [];
                this.sessionData = {
                    startTime: Date.now(),
                    pageViews: 0,
                    interactions: 0,
                    chatMessages: 0,
                    timeSpent: 0,
                    userAgent: navigator.userAgent,
                    language: navigator.language,
                    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                    referrer: document.referrer
                };
                this.heatmapData = [];
                this.scrollDepth = 0;
            }
            
            init() {
                this.setupEventTracking();
                this.setupHeatmapTracking();
                this.setupScrollTracking();
                this.setupPerformanceTracking();
                this.startSessionTracking();
                console.log('📊 Advanced analytics initialized');
            }
            
            setupEventTracking() {
                // Track all user interactions
                document.addEventListener('click', (e) => {
                    this.trackEvent('click', {
                        element: e.target.tagName,
                        className: e.target.className,
                        text: e.target.textContent?.slice(0, 50),
                        x: e.clientX,
                        y: e.clientY,
                        timestamp: Date.now()
                    });
                });
                
                // Track form interactions
                document.addEventListener('focus', (e) => {
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                        this.trackEvent('form_focus', {
                            field: e.target.name || e.target.placeholder,
                            type: e.target.type
                        });
                    }
                }, true);
                
                // Track scroll patterns
                let scrollTimeout;
                window.addEventListener('scroll', () => {
                    clearTimeout(scrollTimeout);
                    scrollTimeout = setTimeout(() => {
                        this.trackScrollDepth();
                    }, 150);
                });
                
                // Track page visibility
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        this.trackEvent('page_hidden');
                    } else {
                        this.trackEvent('page_visible');
                    }
                });
            }
            
            setupHeatmapTracking() {
                let heatmapTimeout;
                document.addEventListener('mousemove', (e) => {
                    clearTimeout(heatmapTimeout);
                    heatmapTimeout = setTimeout(() => {
                        this.heatmapData.push({
                            x: e.clientX,
                            y: e.clientY,
                            timestamp: Date.now()
                        });
                        
                        // Keep only last 500 points for performance
                        if (this.heatmapData.length > 500) {
                            this.heatmapData = this.heatmapData.slice(-500);
                        }
                    }, 100);
                });
            }
            
            setupScrollTracking() {
                let maxScroll = 0;
                window.addEventListener('scroll', () => {
                    const scrollPercent = Math.round(
                        (window.scrollY / (document.documentElement.scrollHeight - window.innerHeight)) * 100
                    );
                    
                    if (scrollPercent > maxScroll) {
                        maxScroll = scrollPercent;
                        this.scrollDepth = maxScroll;
                        
                        // Track scroll milestones
                        if ([25, 50, 75, 90, 100].includes(scrollPercent)) {
                            this.trackEvent('scroll_depth', { depth: scrollPercent });
                        }
                    }
                });
            }
            
            setupPerformanceTracking() {
                // Track Core Web Vitals
                if ('PerformanceObserver' in window) {
                    // Largest Contentful Paint
                    new PerformanceObserver((entryList) => {
                        const entries = entryList.getEntries();
                        const lastEntry = entries[entries.length - 1];
                        this.trackEvent('lcp', { value: lastEntry.startTime });
                    }).observe({ entryTypes: ['largest-contentful-paint'] });
                    
                    // First Input Delay
                    new PerformanceObserver((entryList) => {
                        const firstInput = entryList.getEntries()[0];
                        this.trackEvent('fid', { value: firstInput.processingStart - firstInput.startTime });
                    }).observe({ entryTypes: ['first-input'] });
                    
                    // Cumulative Layout Shift
                    let clsValue = 0;
                    new PerformanceObserver((entryList) => {
                        for (const entry of entryList.getEntries()) {
                            if (!entry.hadRecentInput) {
                                clsValue += entry.value;
                            }
                        }
                        this.trackEvent('cls', { value: clsValue });
                    }).observe({ entryTypes: ['layout-shift'] });
                }
            }
            
            startSessionTracking() {
                // Track session duration
                setInterval(() => {
                    this.sessionData.timeSpent = Date.now() - this.sessionData.startTime;
                }, 10000); // Every 10 seconds
                
                // Send session data before page unload
                window.addEventListener('beforeunload', () => {
                    this.sendSessionData();
                });
                
                // Track page performance
                window.addEventListener('load', () => {
                    const perfData = performance.getEntriesByType('navigation')[0];
                    this.trackEvent('page_load', {
                        loadTime: perfData.loadEventEnd - perfData.loadEventStart,
                        domContentLoaded: perfData.domContentLoadedEventEnd - perfData.domContentLoadedEventStart,
                        firstByte: perfData.responseStart - perfData.requestStart
                    });
                });
            }
            
            trackEvent(eventName, data = {}) {
                const event = {
                    name: eventName,
                    data: data,
                    timestamp: Date.now(),
                    url: window.location.href,
                    sessionId: this.getSessionId()
                };
                
                this.events.push(event);
                this.sessionData.interactions++;
                
                // Log for debugging
                console.log('📈 Event tracked:', eventName, data);
                
                // Send to analytics service (implement based on your needs)
                this.sendEventToAnalytics(event);
                
                return event;
            }
            
            trackScrollDepth() {
                this.trackEvent('scroll_position', {
                    depth: this.scrollDepth,
                    position: window.scrollY
                });
            }
            
            getSessionId() {
                let sessionId = sessionStorage.getItem('sessionId');
                if (!sessionId) {
                    sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                    sessionStorage.setItem('sessionId', sessionId);
                }
                return sessionId;
            }
            
            sendEventToAnalytics(event) {
                // Example: Send to Google Analytics 4
                if (typeof gtag !== 'undefined') {
                    gtag('event', event.name, {
                        custom_parameter: JSON.stringify(event.data),
                        session_id: event.sessionId
                    });
                }
                
                // Example: Send to custom analytics endpoint
                // fetch('/api/analytics', {
                //     method: 'POST',
                //     body: JSON.stringify(event),
                //     headers: { 'Content-Type': 'application/json' }
                // });
            }
            
            sendSessionData() {
                this.sessionData.timeSpent = Date.now() - this.sessionData.startTime;
                this.sessionData.scrollDepth = this.scrollDepth;
                this.sessionData.events = this.events.length;
                
                console.log('📊 Session data:', this.sessionData);
                
                // Send session summary
                this.trackEvent('session_end', this.sessionData);
            }
            
            // Public API for custom tracking
            track(eventName, data) {
                return this.trackEvent(eventName, data);
            }
            
            getAnalytics() {
                return {
                    events: this.events,
                    sessionData: this.sessionData,
                    heatmapData: this.heatmapData
                };
            }
        }
        
        // Enhanced Chat Features
        class ChatEnhancer {
            constructor() {
                this.chatHistory = [];
                this.quickReplies = [];
                this.chatMetrics = {
                    messagesExchanged: 0,
                    averageResponseTime: 0,
                    userSatisfaction: null,
                    topicsDiscussed: []
                };
            }
            
            init() {
                this.setupChatHistoryTracking();
                this.setupQuickReplies();
                this.setupVoiceInput();
                this.setupFileUpload();
                this.setupChatMetrics();
                this.setupMessageEnhancements();
                console.log('💬 Enhanced chat features initialized');
            }
            
            setupChatHistoryTracking() {
                // Monitor chat messages
                const chatObserver = new MutationObserver((mutations) => {
                    mutations.forEach((mutation) => {
                        mutation.addedNodes.forEach((node) => {
                            if (node.nodeType === 1 && node.textContent) {
                                // Detect new messages
                                if (node.classList?.contains('message') || 
                                    node.querySelector?.('.message') ||
                                    (node.textContent.length > 10 && this.isLikelyMessage(node))) {
                                    
                                    this.trackChatMessage(node);
                                }
                            }
                        });
                    });
                });
                
                // Start observing when chat loads
                setTimeout(() => {
                    const chatContainer = document.querySelector('.n8n-chat, #chat-widget-container');
                    if (chatContainer) {
                        chatObserver.observe(chatContainer, { 
                            childList: true, 
                            subtree: true 
                        });
                    }
                }, 3000);
            }
            
            isLikelyMessage(node) {
                const text = node.textContent.trim();
                return text.length > 10 && 
                       !text.includes('Type your message') &&
                       !text.includes('Loading') &&
                       !text.includes('skeleton');
            }
            
            trackChatMessage(messageNode) {
                const message = {
                    content: messageNode.textContent.trim(),
                    timestamp: Date.now(),
                    isUser: this.detectUserMessage(messageNode),
                    length: messageNode.textContent.length
                };
                
                this.chatHistory.push(message);
                this.chatMetrics.messagesExchanged++;
                
                // Track with analytics
                window.analytics?.track('chat_message', {
                    messageLength: message.length,
                    isUser: message.isUser,
                    messageNumber: this.chatHistory.length
                });
                
                // Update metrics
                this.updateChatMetrics(message);
                
                console.log('💬 Message tracked:', message);
            }
            
            detectUserMessage(node) {
                // Heuristics to detect if message is from user
                const classNames = node.className || '';
                const parentClassNames = node.parentElement?.className || '';
                
                return classNames.includes('user') || 
                       parentClassNames.includes('user') ||
                       node.style.textAlign === 'right' ||
                       getComputedStyle(node).textAlign === 'right';
            }
            
            updateChatMetrics(message) {
                // Calculate response time for bot messages
                if (!message.isUser && this.chatHistory.length > 1) {
                    const lastUserMessage = [...this.chatHistory].reverse().find(m => m.isUser);
                    if (lastUserMessage) {
                        const responseTime = message.timestamp - lastUserMessage.timestamp;
                        this.chatMetrics.averageResponseTime = 
                            (this.chatMetrics.averageResponseTime + responseTime) / 2;
                    }
                }
                
                // Extract topics using simple keyword analysis
                this.extractTopics(message.content);
            }
            
            extractTopics(text) {
                const keywords = text.toLowerCase().match(/\b\w{4,}\b/g) || [];
                const importantKeywords = keywords.filter(word => 
                    !['this', 'that', 'with', 'have', 'will', 'from', 'they', 'been', 'said', 'each', 'which'].includes(word)
                );
                
                importantKeywords.forEach(keyword => {
                    const existing = this.chatMetrics.topicsDiscussed.find(t => t.topic === keyword);
                    if (existing) {
                        existing.count++;
                    } else if (importantKeywords.length < 10) { // Avoid spam
                        this.chatMetrics.topicsDiscussed.push({ topic: keyword, count: 1 });
                    }
                });
                
                // Keep only top 20 topics
                this.chatMetrics.topicsDiscussed.sort((a, b) => b.count - a.count);
                this.chatMetrics.topicsDiscussed = this.chatMetrics.topicsDiscussed.slice(0, 20);
            }
            
            setupQuickReplies() {
                this.quickReplies = [
                    "Tell me about Matthew's background",
                    "What projects has he worked on?",
                    "What are his technical skills?",
                    "How can I contact Matthew?",
                    "What's his experience with AI?",
                    "Tell me about his education"
                ];
                
                // Add quick replies to chat interface when appropriate
                setTimeout(() => {
                    this.addQuickRepliesToChat();
                }, 5000);
            }
            
            addQuickRepliesToChat() {
                const chatContainer = document.querySelector('#chat-widget-container');
                if (chatContainer && !chatContainer.querySelector('.quick-replies')) {
                    const quickRepliesHTML = `
                        <div class="quick-replies" style="
                            position: absolute;
                            bottom: 70px;
                            left: 24px;
                            right: 24px;
                            display: flex;
                            flex-wrap: wrap;
                            gap: 8px;
                            opacity: 0;
                            transition: opacity 0.3s ease;
                            pointer-events: none;
                            z-index: 10;
                        ">
                            ${this.quickReplies.map(reply => `
                                <button onclick="window.chatEnhancer.sendQuickReply('${reply}')" style="
                                    background: rgba(99, 102, 241, 0.1);
                                    border: 1px solid rgba(99, 102, 241, 0.3);
                                    color: var(--primary-color);
                                    padding: 6px 12px;
                                    border-radius: 16px;
                                    font-size: 12px;
                                    cursor: pointer;
                                    transition: all 0.2s ease;
                                " onmouseover="this.style.background='rgba(99, 102, 241, 0.2)'"
                                   onmouseout="this.style.background='rgba(99, 102, 241, 0.1)'">
                                    ${reply}
                                </button>
                            `).join('')}
                        </div>
                    `;
                    
                    chatContainer.insertAdjacentHTML('beforeend', quickRepliesHTML);
                    
                    // Show after delay
                    setTimeout(() => {
                        const quickReplies = chatContainer.querySelector('.quick-replies');
                        if (quickReplies) {
                            quickReplies.style.opacity = '1';
                            quickReplies.style.pointerEvents = 'all';
                        }
                    }, 2000);
                }
            }
            
            sendQuickReply(message) {
                const chatInput = document.querySelector('.n8n-chat input, .n8n-chat textarea');
                if (chatInput) {
                    chatInput.value = message;
                    chatInput.dispatchEvent(new Event('input', { bubbles: true }));
                    
                    // Try to trigger send
                    const sendButton = document.querySelector('.n8n-chat button[type="submit"], .n8n-chat .send-button');
                    if (sendButton) {
                        sendButton.click();
                    }
                    
                    // Hide quick replies after use
                    const quickReplies = document.querySelector('.quick-replies');
                    if (quickReplies) {
                        quickReplies.style.opacity = '0';
                        setTimeout(() => quickReplies.remove(), 300);
                    }
                    
                    // Track usage
                    window.analytics?.track('quick_reply_used', { message });
                }
            }
            
            setupVoiceInput() {
                if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                    this.addVoiceInputButton();
                }
            }
            
            addVoiceInputButton() {
                setTimeout(() => {
                    const chatInput = document.querySelector('.n8n-chat .chat-input, .n8n-chat [class*="input"]');
                    if (chatInput && !chatInput.querySelector('.voice-button')) {
                        const voiceButton = document.createElement('button');
                        voiceButton.className = 'voice-button';
                        voiceButton.innerHTML = '🎤';
                        voiceButton.style.cssText = `
                            width: 40px;
                            height: 40px;
                            border-radius: 50%;
                            background: #f3f4f6;
                            border: 1px solid #d1d5db;
                            cursor: pointer;
                            transition: all 0.2s ease;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            font-size: 16px;
                        `;
                        
                        voiceButton.addEventListener('click', () => this.startVoiceRecognition());
                        chatInput.appendChild(voiceButton);
                    }
                }, 3000);
            }
            
            startVoiceRecognition() {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                const recognition = new SpeechRecognition();
                
                recognition.continuous = false;
                recognition.interimResults = false;
                recognition.lang = 'en-US';
                
                recognition.onstart = () => {
                    const voiceButton = document.querySelector('.voice-button');
                    if (voiceButton) {
                        voiceButton.style.background = '#ef4444';
                        voiceButton.innerHTML = '🔴';
                    }
                    window.showNotification?.('Listening... Speak now', 'info', 2000);
                };
                
                recognition.onresult = (event) => {
                    const transcript = event.results[0][0].transcript;
                    const chatInput = document.querySelector('.n8n-chat input, .n8n-chat textarea');
                    if (chatInput) {
                        chatInput.value = transcript;
                        chatInput.dispatchEvent(new Event('input', { bubbles: true }));
                    }
                    
                    window.analytics?.track('voice_input_used', { transcript: transcript.length });
                };
                
                recognition.onend = () => {
                    const voiceButton = document.querySelector('.voice-button');
                    if (voiceButton) {
                        voiceButton.style.background = '#f3f4f6';
                        voiceButton.innerHTML = '🎤';
                    }
                };
                
                recognition.onerror = (event) => {
                    window.showNotification?.('Voice recognition error. Please try again.', 'error');
                    console.error('Speech recognition error:', event.error);
                };
                
                recognition.start();
            }
            
            setupFileUpload() {
                // File upload functionality will be added when n8n supports it
                // For now, we'll prepare the infrastructure
                this.supportedFileTypes = ['.txt', '.pdf', '.doc', '.docx', '.jpg', '.png'];
            }
            
            setupMessageEnhancements() {
                // Add message timestamps, read receipts, etc.
                // This will enhance the chat experience
            }
            
            // Public API
            getChatHistory() {
                return this.chatHistory;
            }
            
            getChatMetrics() {
                return this.chatMetrics;
            }
            
            exportChatHistory() {
                const data = {
                    history: this.chatHistory,
                    metrics: this.chatMetrics,
                    exportedAt: new Date().toISOString()
                };
                
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `matthew-ai-chat-${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
                
                window.analytics?.track('chat_exported');
            }
        }
        
        // Performance Monitoring System
        class PerformanceMonitor {
            constructor() {
                this.metrics = {
                    pageLoadTime: 0,
                    renderTime: 0,
                    interactionToNextPaint: [],
                    memoryUsage: [],
                    networkRequests: [],
                    errorRate: 0,
                    userJourney: []
                };
                this.thresholds = {
                    pageLoad: 3000, // 3 seconds
                    interaction: 100, // 100ms
                    memoryWarning: 50 * 1024 * 1024, // 50MB
                    errorRateAlert: 0.05 // 5%
                };
            }
            
            init() {
                this.setupPerformanceObservers();
                this.setupMemoryMonitoring();
                this.setupNetworkMonitoring();
                this.setupErrorTracking();
                this.setupUserJourneyTracking();
                this.startRealTimeMonitoring();
                console.log('⚡ Advanced performance monitoring initialized');
            }
            
            setupPerformanceObservers() {
                if ('PerformanceObserver' in window) {
                    // Measure Core Web Vitals with better precision
                    const observer = new PerformanceObserver((list) => {
                        for (const entry of list.getEntries()) {
                            this.processPerformanceEntry(entry);
                        }
                    });
                    
                    observer.observe({ entryTypes: ['navigation', 'measure', 'paint', 'largest-contentful-paint', 'first-input', 'layout-shift'] });
                    
                    // Custom performance marks
                    performance.mark('app-start');
                    setTimeout(() => {
                        performance.mark('app-interactive');
                        performance.measure('time-to-interactive', 'app-start', 'app-interactive');
                    }, 1000);
                }
            }
            
            processPerformanceEntry(entry) {
                switch (entry.entryType) {
                    case 'navigation':
                        this.metrics.pageLoadTime = entry.loadEventEnd - entry.loadEventStart;
                        break;
                    case 'paint':
                        if (entry.name === 'first-contentful-paint') {
                            this.metrics.renderTime = entry.startTime;
                        }
                        break;
                    case 'first-input':
                        this.metrics.interactionToNextPaint.push(entry.processingStart - entry.startTime);
                        break;
                    case 'measure':
                        if (entry.name === 'time-to-interactive') {
                            console.log(`⚡ Time to Interactive: ${entry.duration}ms`);
                        }
                        break;
                }
                
                // Alert on poor performance
                this.checkPerformanceThresholds(entry);
            }
            
            setupMemoryMonitoring() {
                if ('memory' in performance) {
                    setInterval(() => {
                        const memInfo = performance.memory;
                        this.metrics.memoryUsage.push({
                            used: memInfo.usedJSHeapSize,
                            total: memInfo.totalJSHeapSize,
                            limit: memInfo.jsHeapSizeLimit,
                            timestamp: Date.now()
                        });
                        
                        // Keep only last 50 measurements
                        if (this.metrics.memoryUsage.length > 50) {
                            this.metrics.memoryUsage = this.metrics.memoryUsage.slice(-50);
                        }
                        
                        // Alert on high memory usage
                        if (memInfo.usedJSHeapSize > this.thresholds.memoryWarning) {
                            console.warn('⚠️ High memory usage detected:', memInfo.usedJSHeapSize / (1024 * 1024), 'MB');
                            this.optimizeMemoryUsage();
                        }
                    }, 5000);
                }
            }
            
            setupNetworkMonitoring() {
                // Monitor fetch requests
                const originalFetch = window.fetch;
                window.fetch = async (...args) => {
                    const startTime = Date.now();
                    try {
                        const response = await originalFetch(...args);
                        this.logNetworkRequest(args[0], response.status, Date.now() - startTime, true);
                        return response;
                    } catch (error) {
                        this.logNetworkRequest(args[0], 0, Date.now() - startTime, false);
                        throw error;
                    }
                };
                
                // Monitor XMLHttpRequest
                const originalXHR = window.XMLHttpRequest;
                window.XMLHttpRequest = function() {
                    const xhr = new originalXHR();
                    const startTime = Date.now();
                    
                    xhr.addEventListener('loadend', () => {
                        window.performanceMonitor?.logNetworkRequest(
                            xhr.responseURL, 
                            xhr.status, 
                            Date.now() - startTime, 
                            xhr.status >= 200 && xhr.status < 400
                        );
                    });
                    
                    return xhr;
                };
            }
            
            logNetworkRequest(url, status, duration, success) {
                this.metrics.networkRequests.push({
                    url: url.toString(),
                    status,
                    duration,
                    success,
                    timestamp: Date.now()
                });
                
                // Keep only last 100 requests
                if (this.metrics.networkRequests.length > 100) {
                    this.metrics.networkRequests = this.metrics.networkRequests.slice(-100);
                }
                
                // Calculate error rate
                const recentRequests = this.metrics.networkRequests.slice(-20);
                const errorRate = recentRequests.filter(r => !r.success).length / recentRequests.length;
                this.metrics.errorRate = errorRate;
                
                if (errorRate > this.thresholds.errorRateAlert) {
                    console.warn('⚠️ High error rate detected:', Math.round(errorRate * 100) + '%');
                }
            }
            
            setupErrorTracking() {
                window.addEventListener('error', (event) => {
                    this.trackError('javascript', event.error, event.filename, event.lineno);
                });
                
                window.addEventListener('unhandledrejection', (event) => {
                    this.trackError('promise', event.reason, 'unhandled-promise');
                });
            }
            
            trackError(type, error, source, line) {
                const errorData = {
                    type,
                    message: error?.message || error?.toString() || 'Unknown error',
                    source,
                    line,
                    stack: error?.stack,
                    timestamp: Date.now(),
                    userAgent: navigator.userAgent,
                    url: window.location.href
                };
                
                console.error('🔥 Error tracked:', errorData);
                
                // Send to error tracking service
                window.analytics?.track('error_occurred', errorData);
                
                // Update error rate
                this.updateErrorRate();
            }
            
            setupUserJourneyTracking() {
                // Track user journey milestones
                const milestones = [
                    { selector: '#hero-section', name: 'viewed_hero' },
                    { selector: '#about-section', name: 'viewed_about' },
                    { selector: '#projects-section', name: 'viewed_projects' },
                    { selector: '#skills-section', name: 'viewed_skills' },
                    { selector: '#chat-widget-container', name: 'viewed_chat' }
                ];
                
                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const milestone = milestones.find(m => entry.target.matches(m.selector));
                            if (milestone && !this.metrics.userJourney.find(j => j.milestone === milestone.name)) {
                                this.metrics.userJourney.push({
                                    milestone: milestone.name,
                                    timestamp: Date.now(),
                                    scrollDepth: Math.round((window.scrollY / document.documentElement.scrollHeight) * 100)
                                });
                                
                                window.analytics?.track('user_journey', milestone);
                            }
                        }
                    });
                }, { threshold: 0.5 });
                
                setTimeout(() => {
                    milestones.forEach(milestone => {
                        const element = document.querySelector(milestone.selector);
                        if (element) observer.observe(element);
                    });
                }, 1000);
            }
            
            startRealTimeMonitoring() {
                setInterval(() => {
                    this.generatePerformanceReport();
                }, 30000); // Every 30 seconds
            }
            
            checkPerformanceThresholds(entry) {
                if (entry.entryType === 'navigation' && entry.loadEventEnd - entry.loadEventStart > this.thresholds.pageLoad) {
                    console.warn('⚠️ Slow page load detected:', entry.loadEventEnd - entry.loadEventStart, 'ms');
                }
                
                if (entry.entryType === 'first-input' && entry.processingStart - entry.startTime > this.thresholds.interaction) {
                    console.warn('⚠️ Slow interaction detected:', entry.processingStart - entry.startTime, 'ms');
                }
            }
            
            optimizeMemoryUsage() {
                // Basic memory optimization
                if (window.gc) {
                    window.gc();
                }
                
                // Clear old analytics data
                if (window.analytics?.events?.length > 1000) {
                    window.analytics.events = window.analytics.events.slice(-500);
                }
            }
            
            updateErrorRate() {
                // Implementation for error rate calculation
            }
            
            generatePerformanceReport() {
                const report = {
                    timestamp: Date.now(),
                    pageLoadTime: this.metrics.pageLoadTime,
                    renderTime: this.metrics.renderTime,
                    averageInteractionTime: this.metrics.interactionToNextPaint.length > 0 ? 
                        this.metrics.interactionToNextPaint.reduce((a, b) => a + b, 0) / this.metrics.interactionToNextPaint.length : 0,
                    currentMemoryUsage: performance.memory ? performance.memory.usedJSHeapSize : 0,
                    errorRate: this.metrics.errorRate,
                    networkPerformance: this.getNetworkPerformance(),
                    userJourneyProgress: this.metrics.userJourney.length
                };
                
                console.log('📊 Performance Report:', report);
                return report;
            }
            
            getNetworkPerformance() {
                const recent = this.metrics.networkRequests.slice(-10);
                if (recent.length === 0) return null;
                
                return {
                    averageResponseTime: recent.reduce((acc, req) => acc + req.duration, 0) / recent.length,
                    successRate: recent.filter(req => req.success).length / recent.length
                };
            }
            
            // Public API
            getMetrics() {
                return this.metrics;
            }
            
            getReport() {
                return this.generatePerformanceReport();
            }
        }
        
        // Security Management System
        class SecurityManager {
            constructor() {
                this.securityMetrics = {
                    suspiciousActivities: [],
                    blockedRequests: [],
                    securityHeaders: {},
                    csrfTokens: new Map(),
                    rateLimits: new Map()
                };
                this.config = {
                    maxRequestsPerMinute: 60,
                    suspiciousActivityThreshold: 10,
                    blockedDomains: ['malicious-site.com'],
                    allowedFileTypes: ['.txt', '.pdf', '.doc', '.docx', '.jpg', '.png', '.gif']
                };
            }
            
            init() {
                this.setupCSP();
                this.setupRateLimiting();
                this.setupInputSanitization();
                this.setupActivityMonitoring();
                this.setupSecurityHeaders();
                this.setupXSSProtection();
                console.log('🔒 Advanced security features initialized');
            }
            
            setupCSP() {
                // Content Security Policy
                const csp = "default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https:; style-src 'self' 'unsafe-inline' https:; img-src 'self' data: https:; connect-src 'self' https:; font-src 'self' https:;";
                
                const meta = document.createElement('meta');
                meta.httpEquiv = 'Content-Security-Policy';
                meta.content = csp;
                document.head.appendChild(meta);
                
                console.log('🔒 Content Security Policy enabled');
            }
            
            setupRateLimiting() {
                const requestCounts = new Map();
                
                // Override fetch to implement rate limiting
                const originalFetch = window.fetch;
                window.fetch = async (url, options = {}) => {
                    const origin = new URL(url, window.location.origin).origin;
                    
                    if (!this.checkRateLimit(origin)) {
                        console.warn('🔒 Rate limit exceeded for:', origin);
                        this.securityMetrics.blockedRequests.push({
                            type: 'rate_limit',
                            url: url.toString(),
                            timestamp: Date.now()
                        });
                        throw new Error('Rate limit exceeded');
                    }
                    
                    return originalFetch(url, options);
                };
            }
            
            checkRateLimit(identifier) {
                const now = Date.now();
                const windowSize = 60000; // 1 minute
                
                if (!this.securityMetrics.rateLimits.has(identifier)) {
                    this.securityMetrics.rateLimits.set(identifier, []);
                }
                
                const requests = this.securityMetrics.rateLimits.get(identifier);
                
                // Remove old requests outside the window
                const recentRequests = requests.filter(time => now - time < windowSize);
                this.securityMetrics.rateLimits.set(identifier, recentRequests);
                
                // Check if under limit
                if (recentRequests.length >= this.config.maxRequestsPerMinute) {
                    return false;
                }
                
                // Add current request
                recentRequests.push(now);
                return true;
            }
            
            setupInputSanitization() {
                // Sanitize user inputs
                document.addEventListener('input', (event) => {
                    if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
                        const sanitized = this.sanitizeInput(event.target.value);
                        if (sanitized !== event.target.value) {
                            console.warn('🔒 Potentially malicious input detected and sanitized');
                            event.target.value = sanitized;
                            
                            this.securityMetrics.suspiciousActivities.push({
                                type: 'malicious_input',
                                original: event.target.value,
                                sanitized: sanitized,
                                timestamp: Date.now()
                            });
                        }
                    }
                });
            }
            
            sanitizeInput(input) {
                // Basic XSS prevention
                return input
                    .replace(/[<>]/g, '')
                    .replace(/javascript:/gi, '')
                    .replace(/on\w+=/gi, '')
                    .replace(/eval\(/gi, '')
                    .replace(/script/gi, '');
            }
            
            setupActivityMonitoring() {
                // Monitor for suspicious activities
                let rapidClicks = 0;
                let rapidClickTimer;
                
                document.addEventListener('click', () => {
                    rapidClicks++;
                    clearTimeout(rapidClickTimer);
                    
                    if (rapidClicks > this.config.suspiciousActivityThreshold) {
                        this.flagSuspiciousActivity('rapid_clicking', { clicks: rapidClicks });
                        rapidClicks = 0;
                    }
                    
                    rapidClickTimer = setTimeout(() => {
                        rapidClicks = 0;
                    }, 1000);
                });
                
                // Monitor for copy/paste of large amounts of data
                document.addEventListener('paste', (event) => {
                    const pastedData = event.clipboardData?.getData('text') || '';
                    if (pastedData.length > 10000) {
                        this.flagSuspiciousActivity('large_paste', { length: pastedData.length });
                    }
                });
                
                // Monitor for unusual navigation patterns
                let pageChanges = 0;
                window.addEventListener('popstate', () => {
                    pageChanges++;
                    if (pageChanges > 20) {
                        this.flagSuspiciousActivity('excessive_navigation', { changes: pageChanges });
                    }
                });
            }
            
            flagSuspiciousActivity(type, data) {
                this.securityMetrics.suspiciousActivities.push({
                    type,
                    data,
                    timestamp: Date.now(),
                    userAgent: navigator.userAgent,
                    ip: 'client-side', // Would get real IP server-side
                    url: window.location.href
                });
                
                console.warn('🔒 Suspicious activity detected:', type, data);
                
                // Take action based on severity
                if (this.securityMetrics.suspiciousActivities.length > 5) {
                    this.triggerSecurityAlert();
                }
            }
            
            setupSecurityHeaders() {
                // Verify security headers (would be set server-side in production)
                this.securityMetrics.securityHeaders = {
                    'X-Frame-Options': 'DENY',
                    'X-Content-Type-Options': 'nosniff',
                    'X-XSS-Protection': '1; mode=block',
                    'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',
                    'Referrer-Policy': 'strict-origin-when-cross-origin'
                };
            }
            
            setupXSSProtection() {
                // Advanced XSS protection
                const observer = new MutationObserver((mutations) => {
                    mutations.forEach((mutation) => {
                        mutation.addedNodes.forEach((node) => {
                            if (node.nodeType === 1) { // Element node
                                this.scanForXSS(node);
                            }
                        });
                    });
                });
                
                observer.observe(document.body, { childList: true, subtree: true });
            }
            
            scanForXSS(element) {
                // Check for potentially dangerous attributes and content
                const dangerousAttributes = ['onclick', 'onload', 'onerror', 'onmouseover'];
                const dangerousContent = ['javascript:', 'data:text/html', '<script'];
                
                dangerousAttributes.forEach(attr => {
                    if (element.hasAttribute && element.hasAttribute(attr)) {
                        console.warn('🔒 Dangerous attribute detected:', attr);
                        element.removeAttribute(attr);
                        this.flagSuspiciousActivity('xss_attempt', { attribute: attr });
                    }
                });
                
                if (element.innerHTML) {
                    dangerousContent.forEach(content => {
                        if (element.innerHTML.toLowerCase().includes(content.toLowerCase())) {
                            console.warn('🔒 Dangerous content detected:', content);
                            this.flagSuspiciousActivity('xss_content', { content });
                        }
                    });
                }
            }
            
            triggerSecurityAlert() {
                console.error('🚨 SECURITY ALERT: Multiple suspicious activities detected!');
                
                // In production, this would:
                // 1. Send alert to security team
                // 2. Log detailed security event
                // 3. Potentially block user session
                // 4. Increase monitoring
                
                window.showNotification?.('Security monitoring detected unusual activity. Please contact support if you are experiencing issues.', 'warning', 10000);
            }
            
            // Public API
            getSecurityReport() {
                return {
                    suspiciousActivities: this.securityMetrics.suspiciousActivities.length,
                    blockedRequests: this.securityMetrics.blockedRequests.length,
                    securityHeaders: this.securityMetrics.securityHeaders,
                    lastActivity: this.securityMetrics.suspiciousActivities.slice(-5)
                };
            }
            
            isSecure() {
                return this.securityMetrics.suspiciousActivities.length < 3 &&
                       this.securityMetrics.blockedRequests.length < 10;
            }
        }
        
        // Business Intelligence System
        class BusinessIntelligence {
            constructor() {
                this.data = {
                    userSegments: new Map(),
                    conversionFunnels: [],
                    behaviorPatterns: [],
                    businessMetrics: {
                        uniqueVisitors: 0,
                        pageViews: 0,
                        bounceRate: 0,
                        avgSessionDuration: 0,
                        conversionRate: 0,
                        chatEngagement: 0
                    },
                    insights: []
                };
                this.goals = {
                    chatInitiation: false,
                    messageExchange: false,
                    contactFormFill: false,
                    projectInquiry: false,
                    skillsViewed: false
                };
            }
            
            init() {
                this.setupUserSegmentation();
                this.setupConversionTracking();
                this.setupBehaviorAnalysis();
                this.setupBusinessMetrics();
                this.setupInsightGeneration();
                this.startIntelligenceEngine();
                console.log('🧠 Business intelligence system initialized');
            }
            
            setupUserSegmentation() {
                // Segment users based on behavior
                const segmentUser = () => {
                    const sessionData = window.analytics?.sessionData || {};
                    const behavior = {
                        timeOnSite: sessionData.timeSpent || 0,
                        pageViews: sessionData.pageViews || 0,
                        interactions: sessionData.interactions || 0,
                        device: this.getDeviceType(),
                        source: this.getTrafficSource(),
                        engagement: this.calculateEngagementScore()
                    };
                    
                    let segment = 'visitor';
                    
                    if (behavior.timeOnSite > 300000 && behavior.interactions > 10) {
                        segment = 'highly_engaged';
                    } else if (behavior.timeOnSite > 120000 && behavior.interactions > 5) {
                        segment = 'engaged';
                    } else if (this.goals.chatInitiation) {
                        segment = 'chat_user';
                    } else if (behavior.timeOnSite < 30000) {
                        segment = 'bounced';
                    }
                    
                    this.updateUserSegment(segment, behavior);
                };
                
                // Run segmentation periodically
                setInterval(segmentUser, 60000); // Every minute
                setTimeout(segmentUser, 10000); // Initial run
            }
            
            updateUserSegment(segment, behavior) {
                if (!this.data.userSegments.has(segment)) {
                    this.data.userSegments.set(segment, {
                        count: 0,
                        averageBehavior: { ...behavior },
                        goals: { ...this.goals }
                    });
                }
                
                const segmentData = this.data.userSegments.get(segment);
                segmentData.count++;
                
                // Update average behavior
                Object.keys(behavior).forEach(key => {
                    if (typeof behavior[key] === 'number') {
                        segmentData.averageBehavior[key] = 
                            (segmentData.averageBehavior[key] + behavior[key]) / 2;
                    }
                });
                
                console.log('🎯 User segmented as:', segment, behavior);
            }
            
            getDeviceType() {
                const userAgent = navigator.userAgent;
                if (/tablet|ipad|playbook|silk/i.test(userAgent)) return 'tablet';
                if (/mobile|iphone|ipod|android|blackberry|opera|mini|windows\sce|palm|smartphone|iemobile/i.test(userAgent)) return 'mobile';
                return 'desktop';
            }
            
            getTrafficSource() {
                const referrer = document.referrer;
                if (!referrer) return 'direct';
                if (referrer.includes('google.com')) return 'google';
                if (referrer.includes('facebook.com')) return 'facebook';
                if (referrer.includes('linkedin.com')) return 'linkedin';
                if (referrer.includes('twitter.com')) return 'twitter';
                return 'other';
            }
            
            calculateEngagementScore() {
                const sessionData = window.analytics?.sessionData || {};
                const chatMetrics = window.chatEnhancer?.getChatMetrics() || {};
                
                let score = 0;
                
                // Time on site (up to 30 points)
                score += Math.min((sessionData.timeSpent || 0) / 10000, 30);
                
                // Interactions (up to 25 points)
                score += Math.min((sessionData.interactions || 0) * 2, 25);
                
                // Chat engagement (up to 25 points)
                score += Math.min((chatMetrics.messagesExchanged || 0) * 5, 25);
                
                // Page depth (up to 20 points)
                score += Math.min((sessionData.scrollDepth || 0) / 5, 20);
                
                return Math.round(score);
            }
            
            setupConversionTracking() {
                // Define conversion funnel
                this.conversionFunnel = [
                    { step: 'page_load', name: 'Page Load' },
                    { step: 'scroll_25', name: '25% Scroll' },
                    { step: 'about_viewed', name: 'About Section Viewed' },
                    { step: 'projects_viewed', name: 'Projects Viewed' },
                    { step: 'chat_initiated', name: 'Chat Started' },
                    { step: 'message_sent', name: 'Message Sent' },
                    { step: 'contact_interest', name: 'Contact Interest' }
                ];
                
                // Track funnel progression
                window.addEventListener('analytics-event', (event) => {
                    this.updateConversionFunnel(event.detail);
                });
            }
            
            updateConversionFunnel(eventData) {
                const funnelEvents = {
                    'page_load': 'page_load',
                    'scroll_depth': (data) => data.depth >= 25 ? 'scroll_25' : null,
                    'user_journey': (data) => {
                        if (data.milestone === 'viewed_about') return 'about_viewed';
                        if (data.milestone === 'viewed_projects') return 'projects_viewed';
                        return null;
                    },
                    'chat_message': 'chat_initiated',
                    'quick_reply_used': 'message_sent'
                };
                
                const funnelStep = typeof funnelEvents[eventData.name] === 'function' 
                    ? funnelEvents[eventData.name](eventData.data)
                    : funnelEvents[eventData.name];
                
                if (funnelStep) {
                    this.data.conversionFunnels.push({
                        step: funnelStep,
                        timestamp: Date.now(),
                        sessionId: eventData.sessionId
                    });
                    
                    this.updateGoals(funnelStep);
                }
            }
            
            updateGoals(step) {
                switch (step) {
                    case 'chat_initiated':
                        this.goals.chatInitiation = true;
                        break;
                    case 'message_sent':
                        this.goals.messageExchange = true;
                        break;
                    case 'projects_viewed':
                        this.goals.projectInquiry = true;
                        break;
                    case 'about_viewed':
                        this.goals.skillsViewed = true;
                        break;
                }
            }
            
            setupBehaviorAnalysis() {
                // Analyze user behavior patterns
                setInterval(() => {
                    this.analyzeBehaviorPatterns();
                }, 120000); // Every 2 minutes
            }
            
            analyzeBehaviorPatterns() {
                const analytics = window.analytics?.getAnalytics();
                if (!analytics) return;
                
                const patterns = {
                    clickPatterns: this.analyzeClickPatterns(analytics.events),
                    scrollPatterns: this.analyzeScrollPatterns(analytics.events),
                    timePatterns: this.analyzeTimePatterns(analytics.events),
                    navigationPatterns: this.analyzeNavigationPatterns(analytics.events)
                };
                
                this.data.behaviorPatterns.push({
                    timestamp: Date.now(),
                    patterns,
                    sessionId: analytics.sessionData.sessionId
                });
                
                console.log('🔍 Behavior patterns analyzed:', patterns);
            }
            
            analyzeClickPatterns(events) {
                const clicks = events.filter(e => e.name === 'click');
                const elementClicks = {};
                
                clicks.forEach(click => {
                    const element = click.data.element || 'unknown';
                    elementClicks[element] = (elementClicks[element] || 0) + 1;
                });
                
                return {
                    totalClicks: clicks.length,
                    mostClicked: Object.keys(elementClicks).reduce((a, b) => 
                        elementClicks[a] > elementClicks[b] ? a : b, 'none'),
                    distribution: elementClicks
                };
            }
            
            analyzeScrollPatterns(events) {
                const scrollEvents = events.filter(e => e.name === 'scroll_depth');
                if (scrollEvents.length === 0) return { maxDepth: 0, averageDepth: 0 };
                
                const depths = scrollEvents.map(e => e.data.depth);
                return {
                    maxDepth: Math.max(...depths),
                    averageDepth: depths.reduce((a, b) => a + b, 0) / depths.length,
                    scrollSpeed: this.calculateScrollSpeed(scrollEvents)
                };
            }
            
            calculateScrollSpeed(scrollEvents) {
                if (scrollEvents.length < 2) return 0;
                
                const speeds = [];
                for (let i = 1; i < scrollEvents.length; i++) {
                    const timeDiff = scrollEvents[i].timestamp - scrollEvents[i-1].timestamp;
                    const depthDiff = Math.abs(scrollEvents[i].data.depth - scrollEvents[i-1].data.depth);
                    if (timeDiff > 0) speeds.push(depthDiff / timeDiff);
                }
                
                return speeds.length > 0 ? speeds.reduce((a, b) => a + b, 0) / speeds.length : 0;
            }
            
            analyzeTimePatterns(events) {
                const sessionStart = Math.min(...events.map(e => e.timestamp));
                const sessionEnd = Math.max(...events.map(e => e.timestamp));
                const sessionDuration = sessionEnd - sessionStart;
                
                return {
                    sessionDuration,
                    eventFrequency: events.length / (sessionDuration / 1000), // events per second
                    peakActivity: this.findPeakActivityPeriod(events)
                };
            }
            
            findPeakActivityPeriod(events) {
                // Divide session into 30-second intervals and find peak
                const intervals = {};
                const intervalSize = 30000; // 30 seconds
                
                events.forEach(event => {
                    const interval = Math.floor(event.timestamp / intervalSize) * intervalSize;
                    intervals[interval] = (intervals[interval] || 0) + 1;
                });
                
                const maxInterval = Object.keys(intervals).reduce((a, b) => 
                    intervals[a] > intervals[b] ? a : b, '0');
                
                return {
                    timestamp: parseInt(maxInterval),
                    eventCount: intervals[maxInterval] || 0
                };
            }
            
            analyzeNavigationPatterns(events) {
                const journeyEvents = events.filter(e => e.name === 'user_journey');
                return {
                    milestones: journeyEvents.map(e => e.data.milestone),
                    journeyCompleteness: journeyEvents.length / 5, // 5 main sections
                    navigationSpeed: this.calculateNavigationSpeed(journeyEvents)
                };
            }
            
            calculateNavigationSpeed(journeyEvents) {
                if (journeyEvents.length < 2) return 0;
                
                const totalTime = journeyEvents[journeyEvents.length - 1].timestamp - journeyEvents[0].timestamp;
                const milestonesPerMinute = (journeyEvents.length / (totalTime / 60000));
                return milestonesPerMinute;
            }
            
            setupBusinessMetrics() {
                setInterval(() => {
                    this.updateBusinessMetrics();
                }, 60000); // Update every minute
            }
            
            updateBusinessMetrics() {
                const analytics = window.analytics?.getAnalytics();
                if (!analytics) return;
                
                const session = analytics.sessionData;
                const events = analytics.events;
                
                this.data.businessMetrics = {
                    uniqueVisitors: 1, // Would be tracked server-side
                    pageViews: session.pageViews || 1,
                    bounceRate: session.timeSpent < 30000 ? 1 : 0,
                    avgSessionDuration: session.timeSpent || 0,
                    conversionRate: this.calculateConversionRate(),
                    chatEngagement: this.calculateChatEngagement(),
                    userSatisfaction: this.estimateUserSatisfaction(),
                    goalCompletions: Object.values(this.goals).filter(g => g).length
                };
                
                console.log('📊 Business metrics updated:', this.data.businessMetrics);
            }
            
            calculateConversionRate() {
                const completedGoals = Object.values(this.goals).filter(g => g).length;
                return completedGoals / Object.keys(this.goals).length;
            }
            
            calculateChatEngagement() {
                const chatMetrics = window.chatEnhancer?.getChatMetrics();
                if (!chatMetrics) return 0;
                
                return Math.min(chatMetrics.messagesExchanged * 0.2, 1); // Scale to 0-1
            }
            
            estimateUserSatisfaction() {
                const engagementScore = this.calculateEngagementScore();
                const conversionRate = this.calculateConversionRate();
                const chatEngagement = this.calculateChatEngagement();
                
                // Weighted satisfaction score
                return Math.round(
                    (engagementScore * 0.4 + conversionRate * 100 * 0.4 + chatEngagement * 100 * 0.2)
                );
            }
            
            setupInsightGeneration() {
                setInterval(() => {
                    this.generateInsights();
                }, 300000); // Every 5 minutes
            }
            
            generateInsights() {
                const insights = [];
                const metrics = this.data.businessMetrics;
                const segments = Array.from(this.data.userSegments.entries());
                
                // Engagement insights
                if (metrics.avgSessionDuration > 180000) {
                    insights.push({
                        type: 'positive',
                        category: 'engagement',
                        message: 'Users are spending significant time on the site (>3 minutes)',
                        value: Math.round(metrics.avgSessionDuration / 1000) + 's',
                        timestamp: Date.now()
                    });
                }
                
                // Conversion insights
                if (metrics.conversionRate > 0.6) {
                    insights.push({
                        type: 'positive',
                        category: 'conversion',
                        message: 'High goal completion rate indicates strong user interest',
                        value: Math.round(metrics.conversionRate * 100) + '%',
                        timestamp: Date.now()
                    });
                }
                
                // Chat insights
                if (metrics.chatEngagement > 0.5) {
                    insights.push({
                        type: 'positive',
                        category: 'chat',
                        message: 'Strong chat engagement suggests effective AI interaction',
                        value: Math.round(metrics.chatEngagement * 100) + '%',
                        timestamp: Date.now()
                    });
                }
                
                // Segment insights
                segments.forEach(([segment, data]) => {
                    if (data.count > 0 && segment !== 'visitor') {
                        insights.push({
                            type: 'info',
                            category: 'segmentation',
                            message: `User classified as ${segment} with engagement score ${data.averageBehavior.engagement}`,
                            value: data.count,
                            timestamp: Date.now()
                        });
                    }
                });
                
                this.data.insights = [...this.data.insights, ...insights].slice(-20); // Keep last 20 insights
                
                if (insights.length > 0) {
                    console.log('💡 New insights generated:', insights);
                }
            }
            
            startIntelligenceEngine() {
                // Run comprehensive analysis every 10 minutes
                setInterval(() => {
                    this.runIntelligenceAnalysis();
                }, 600000);
            }
            
            runIntelligenceAnalysis() {
                const report = {
                    timestamp: Date.now(),
                    userSegments: Object.fromEntries(this.data.userSegments),
                    businessMetrics: this.data.businessMetrics,
                    behaviorSummary: this.summarizeBehaviorPatterns(),
                    recommendations: this.generateRecommendations(),
                    insights: this.data.insights.slice(-10)
                };
                
                console.log('🧠 Intelligence Analysis Complete:', report);
                return report;
            }
            
            summarizeBehaviorPatterns() {
                if (this.data.behaviorPatterns.length === 0) return null;
                
                const latest = this.data.behaviorPatterns[this.data.behaviorPatterns.length - 1];
                return {
                    dominantClickElement: latest.patterns.clickPatterns.mostClicked,
                    averageScrollDepth: latest.patterns.scrollPatterns.averageDepth,
                    sessionDuration: latest.patterns.timePatterns.sessionDuration,
                    journeyCompleteness: latest.patterns.navigationPatterns.journeyCompleteness
                };
            }
            
            generateRecommendations() {
                const recommendations = [];
                const metrics = this.data.businessMetrics;
                
                if (metrics.bounceRate > 0.7) {
                    recommendations.push('Consider improving initial page load experience to reduce bounce rate');
                }
                
                if (metrics.chatEngagement < 0.3) {
                    recommendations.push('Enhance chat prompts or add quick reply options to improve engagement');
                }
                
                if (metrics.conversionRate < 0.4) {
                    recommendations.push('Review goal definitions and user journey to improve conversion tracking');
                }
                
                return recommendations;
            }
            
            // Public API
            getBusinessReport() {
                return {
                    metrics: this.data.businessMetrics,
                    segments: Object.fromEntries(this.data.userSegments),
                    insights: this.data.insights.slice(-10),
                    goals: this.goals
                };
            }
            
            getInsights() {
                return this.data.insights;
            }
            
            exportBusinessData() {
                const data = {
                    businessMetrics: this.data.businessMetrics,
                    userSegments: Object.fromEntries(this.data.userSegments),
                    insights: this.data.insights,
                    behaviorPatterns: this.data.behaviorPatterns.slice(-10),
                    goals: this.goals,
                    exportedAt: new Date().toISOString()
                };
                
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `matthew-ai-business-intelligence-${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
                
                window.analytics?.track('business_data_exported');
            }
        }

        // ========================================
        // MAIN INITIALIZATION SYSTEM
        // ========================================
        
        // Initialize all systems
        let healthMonitor, errorHandler, notificationSystem, loadingSystem, themeManager, accessibilityManager;
        let advancedFeatures; // Phase 3 features
        
        // Phase 1 & 2 Systems
        function initializeSystems() {
            console.log('🚀 Initializing Matthew\'s AI Portfolio Systems...');
            
            // Phase 1: Foundation Systems
            healthMonitor = new HealthMonitor();
            errorHandler = new ErrorHandler();
            notificationSystem = new NotificationSystem();
            loadingSystem = new LoadingSystem();
            
            // Phase 2: UX Enhancement Systems
            themeManager = new ThemeManager();
            accessibilityManager = new AccessibilityManager();
            
            // Phase 3: Advanced Features & Intelligence
            advancedFeatures = new AdvancedFeaturesManager();
            
            // Make systems globally accessible
            window.healthMonitor = healthMonitor;
            window.errorHandler = errorHandler;
            window.showNotification = notificationSystem.show.bind(notificationSystem);
            window.loadingSystem = loadingSystem;
            window.themeManager = themeManager;
            window.accessibilityManager = accessibilityManager;
            
            // Phase 3 Global Access
            window.analytics = advancedFeatures.analytics;
            window.chatEnhancer = advancedFeatures.chatEnhancer;
            window.performanceMonitor = advancedFeatures.performanceMonitor;
            window.securityManager = advancedFeatures.securityManager;
            window.businessIntelligence = advancedFeatures.businessIntelligence;
            
            console.log('✨ All systems initialized successfully!');
            
            // Show initialization success
            setTimeout(() => {
                notificationSystem.show('🚀 Enterprise-level systems activated!', 'success', 3000);
            }, 2000);
            
            // Setup developer console API
            setupDeveloperAPI();
        }
        
        // ========================================
        // DEVELOPER API & CONSOLE COMMANDS
        // ========================================
        
        function setupDeveloperAPI() {
            // Create comprehensive developer API
            window.matthewAI = {
                // System Information
                getSystemStatus() {
                    return {
                        health: healthMonitor.getHealthReport(),
                        performance: performanceMonitor.getReport(),
                        security: securityManager.getSecurityReport(),
                        business: businessIntelligence.getBusinessReport(),
                        analytics: analytics.getAnalytics(),
                        chat: chatEnhancer.getChatMetrics(),
                        accessibility: accessibilityManager.getStatus(),
                        theme: themeManager.getCurrentTheme(),
                        timestamp: new Date().toISOString()
                    };
                },
                
                // Analytics & Business Intelligence
                exportAllData() {
                    console.log('📊 Exporting all platform data...');
                    chatEnhancer.exportChatHistory();
                    businessIntelligence.exportBusinessData();
                    this.exportSystemReport();
                },
                
                exportSystemReport() {
                    const report = this.getSystemStatus();
                    const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `matthew-ai-system-report-${Date.now()}.json`;
                    a.click();
                    URL.revokeObjectURL(url);
                    console.log('📊 System report exported');
                },
                
                // Performance Tools
                runPerformanceTest() {
                    console.log('⚡ Running performance diagnostics...');
                    const report = performanceMonitor.generatePerformanceReport();
                    console.table(report);
                    return report;
                },
                
                optimizePerformance() {
                    console.log('🔧 Running performance optimizations...');
                    performanceMonitor.optimizeMemoryUsage();
                    // Clear old data
                    if (analytics.events.length > 500) {
                        analytics.events = analytics.events.slice(-250);
                        console.log('📊 Analytics data optimized');
                    }
                    console.log('✨ Performance optimization complete');
                },
                
                // Security Tools
                runSecurityScan() {
                    console.log('🔒 Running security scan...');
                    const report = securityManager.getSecurityReport();
                    console.table(report);
                    return report;
                },
                
                // Business Intelligence
                getInsights() {
                    const insights = businessIntelligence.getInsights();
                    console.log('💡 Business Insights:', insights);
                    return insights;
                },
                
                getUserSegments() {
                    const segments = businessIntelligence.data.userSegments;
                    console.log('🎯 User Segments:', Object.fromEntries(segments));
                    return Object.fromEntries(segments);
                },
                
                // Chat Tools
                getChatAnalytics() {
                    const metrics = chatEnhancer.getChatMetrics();
                    const history = chatEnhancer.getChatHistory();
                    console.log('💬 Chat Analytics:', { metrics, totalMessages: history.length });
                    return { metrics, totalMessages: history.length, history: history.slice(-10) };
                },
                
                // System Controls
                restartSystems() {
                    console.log('🔄 Restarting systems...');
                    initializeSystems();
                },
                
                enableDebugMode() {
                    window.DEBUG_MODE = true;
                    console.log('🐛 Debug mode enabled - verbose logging activated');
                    document.body.setAttribute('data-debug', 'true');
                },
                
                disableDebugMode() {
                    window.DEBUG_MODE = false;
                    console.log('🐛 Debug mode disabled');
                    document.body.removeAttribute('data-debug');
                },
                
                // Theme & Accessibility
                setTheme(theme) {
                    if (['light', 'dark', 'auto'].includes(theme)) {
                        themeManager.setTheme(theme);
                        console.log(`🎨 Theme changed to: ${theme}`);
                    } else {
                        console.warn('❌ Invalid theme. Use: light, dark, or auto');
                    }
                },
                
                testAccessibility() {
                    console.log('♿ Running accessibility tests...');
                    const status = accessibilityManager.getStatus();
                    console.table(status);
                    return status;
                },
                
                // Utilities
                clearAllData() {
                    if (confirm('⚠️ Clear all stored data? This cannot be undone.')) {
                        localStorage.clear();
                        sessionStorage.clear();
                        console.log('🗑️ All data cleared');
                        location.reload();
                    }
                },
                
                // Help System
                help() {
                    console.log(`
🤖 Matthew's AI Portfolio - Developer API

Available Commands:
===================

📊 ANALYTICS & REPORTING
• matthewAI.getSystemStatus()     - Get comprehensive system status
• matthewAI.exportAllData()       - Export all platform data
• matthewAI.exportSystemReport()  - Export detailed system report

⚡ PERFORMANCE
• matthewAI.runPerformanceTest()  - Run performance diagnostics
• matthewAI.optimizePerformance() - Optimize system performance

🔒 SECURITY
• matthewAI.runSecurityScan()     - Run security diagnostics

🧠 BUSINESS INTELLIGENCE
• matthewAI.getInsights()         - Get AI-generated insights
• matthewAI.getUserSegments()     - View user segmentation data

💬 CHAT ANALYTICS
• matthewAI.getChatAnalytics()    - Get chat interaction data

🔧 SYSTEM CONTROLS
• matthewAI.restartSystems()      - Restart all systems
• matthewAI.enableDebugMode()     - Enable verbose debugging
• matthewAI.disableDebugMode()    - Disable debugging

🎨 CUSTOMIZATION
• matthewAI.setTheme('light|dark|auto') - Change theme
• matthewAI.testAccessibility()   - Run accessibility tests

🛠️ UTILITIES
• matthewAI.clearAllData()        - Clear all stored data
• matthewAI.help()                - Show this help menu

Example Usage:
===============
matthewAI.getSystemStatus()       // View system health
matthewAI.setTheme('dark')        // Switch to dark mode
matthewAI.exportAllData()         // Export analytics data
matthewAI.optimizePerformance()   // Clean up and optimize

💡 Tip: All functions return data that you can inspect!
                    `);
                },
                
                // Version and build info
                version: '3.0.0',
                buildDate: new Date().toISOString(),
                features: [
                    'Enterprise Analytics', 'AI Chat Enhancement', 'Performance Monitoring',
                    'Advanced Security', 'Business Intelligence', 'Real-time Insights',
                    'User Segmentation', 'Conversion Tracking', 'Accessibility',
                    'Dark Mode', 'Voice Input', 'Quick Replies', 'Error Recovery'
                ]
            };
            
            // Welcome message for developers
            console.log(`
🚀 Welcome to Matthew's AI Portfolio v${window.matthewAI.version}

This enterprise-grade platform includes:
✨ Advanced Analytics & Business Intelligence
🔒 Multi-layer Security & Monitoring  
⚡ Real-time Performance Optimization
💬 Enhanced AI Chat with Voice Input
♿ Complete Accessibility Support
🎨 Advanced Theme System

Type 'matthewAI.help()' for available commands
Type 'matthewAI.getSystemStatus()' for current status

Developer API Ready! 🎯
            `);
        }

        // ========================================
        // STARTUP SEQUENCE
        // ========================================
        
        // Initialize everything when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeSystems);
        } else {
            initializeSystems();
        }
    </script>
</body>
</html>
